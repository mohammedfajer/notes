"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[661],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,h=c["".concat(l,".").concat(u)]||c[u]||d[u]||r;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3377:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>A,contentTitle:()=>T,default:()=>P,frontMatter:()=>x,metadata:()=>S,toc:()=>L});var a=n(7462),i=(n(7294),n(3905));const r=n.p+"assets/images/netclasses-0f04c6a3c186bc21c1a445f1a20c301f.png",o=n.p+"assets/images/namespace-8dfd503f04aea03b3f98159cbaf19804.png",s=n.p+"assets/images/assembly-d590e03145e47e959aefde48a791ec35.png",l=n.p+"assets/images/app-de1a721c51bff2e0793b884531c16341.png",p=n.p+"assets/images/arith-97f020fae569b334f1fefdec92f9e352.png",m=n.p+"assets/images/arith1-7b30c90ed3b560f757894daefd0a555b.png",c=n.p+"assets/images/compar-787134f5a4ebbc98a33cbaf29e3d3d52.png",d=n.p+"assets/images/assign_operators-b3d4e502c5bb6641ebb850478f4eae90.png",u=n.p+"assets/images/logical_operators-976c72360ff91d0fa6957f897f437f5e.png",h=n.p+"assets/images/bitwise_operators-6b08a58b27e0a4cc05842a0a24c83233.png",g=n.p+"assets/images/class-9b55ded1f843a2d6b896bb2085544b10.png",k=n.p+"assets/images/static_modifier-3adeafd1c5fabf41bc59006bc112e2a2.png",f=n.p+"assets/images/static_modifier2-1c18424c2fe1893e4d5f338dc2bfe007.png",y=n.p+"assets/images/escape_characters-056ab0425f94ae825f774b092d2602a0.png",w=n.p+"assets/images/refval-45ed18d193eb26a298ea3d0f65ced92b.png",b=n.p+"assets/images/control_structures-a797499abecbb99d9ed84e62fc22e83a.png",v=n.p+"assets/images/mda-25fa3811e38875d08e55527898884e2c.png",N=n.p+"assets/images/jagged-1dbb7882edb89a188b8d6f2544ab64c9.png",C=n.p+"assets/images/array-7d8c58a0a0026ebc8ca95dd2d59aabe3.png",x={},T="C# Basics Part 1",S={unversionedId:"GAP5005 Games Hardware Development/tutorial-csharp/week1",id:"GAP5005 Games Hardware Development/tutorial-csharp/week1",title:"C# Basics Part 1",description:"Basics Part 1",source:"@site/docs/GAP5005 Games Hardware Development/tutorial-csharp/week1.md",sourceDirName:"GAP5005 Games Hardware Development/tutorial-csharp",slug:"/GAP5005 Games Hardware Development/tutorial-csharp/week1",permalink:"/notes/3b5e95ffbb5780e88fb2ad9652b2eb9aadead95d/docs/GAP5005 Games Hardware Development/tutorial-csharp/week1",draft:!1,editUrl:"https://github.com/mohammedfajer/notes/docs/GAP5005 Games Hardware Development/tutorial-csharp/week1.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Tutorial - C# (C-Sharp)",permalink:"/notes/3b5e95ffbb5780e88fb2ad9652b2eb9aadead95d/docs/category/tutorial---c-c-sharp"},next:{title:"C# Basics Part 2",permalink:"/notes/3b5e95ffbb5780e88fb2ad9652b2eb9aadead95d/docs/GAP5005 Games Hardware Development/tutorial-csharp/week2"}},A={},L=[{value:"C# vs. .NET Framework",id:"c-vs-net-framework",level:2},{value:".NET Framework",id:"net-framework",level:2},{value:"CLR (Common Language Runtime)",id:"clr-common-language-runtime",level:2},{value:"Architecture of .NET Applications",id:"architecture-of-net-applications",level:2},{value:"Primitive Types and Expressions",id:"primitive-types-and-expressions",level:2},{value:"Variables and Constants",id:"variables-and-constants",level:3},{value:"Identifiers",id:"identifiers",level:4},{value:"Naming Conventions",id:"naming-conventions",level:4},{value:"Real Numbers",id:"real-numbers",level:5},{value:"Overflowing",id:"overflowing",level:3},{value:"Scope",id:"scope",level:3},{value:"Type Conversions",id:"type-conversions",level:3},{value:"Operators",id:"operators",level:3},{value:"Arithmetic Operators",id:"arithmetic-operators",level:4},{value:"Comparison Operators",id:"comparison-operators",level:4},{value:"Assignment Operators",id:"assignment-operators",level:4},{value:"Logical Operators",id:"logical-operators",level:4},{value:"Bitwise Operators",id:"bitwise-operators",level:4},{value:"Boolean Algebra",id:"boolean-algebra",level:3},{value:"Logical AND",id:"logical-and",level:4},{value:"Logical OR",id:"logical-or",level:4},{value:"Logical NOT",id:"logical-not",level:4},{value:"Comments",id:"comments",level:3},{value:"Single-line Comment",id:"single-line-comment",level:4},{value:"Multi-line Comments",id:"multi-line-comments",level:4},{value:"When to use",id:"when-to-use",level:4},{value:"Non-Primitive Types",id:"non-primitive-types",level:2},{value:"Classes",id:"classes",level:3},{value:"Creating Objects",id:"creating-objects",level:4},{value:"Static Modifier",id:"static-modifier",level:4},{value:"Structs",id:"structs",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Declaring Arrays",id:"declaring-arrays",level:4},{value:"Accessing Array Elements",id:"accessing-array-elements",level:4},{value:"Strings",id:"strings",level:3},{value:"Creating Strings",id:"creating-strings",level:4},{value:"String Elements",id:"string-elements",level:4},{value:"Strings are Immutable",id:"strings-are-immutable",level:4},{value:"Escape Characters",id:"escape-characters",level:4},{value:"Verbatim Strings",id:"verbatim-strings",level:4},{value:"Enums",id:"enums",level:3},{value:"Reference Types and Value Types",id:"reference-types-and-value-types",level:3},{value:"Copying Value Types",id:"copying-value-types",level:4},{value:"Control Flow",id:"control-flow",level:2},{value:"Conditional Statements",id:"conditional-statements",level:3},{value:"If / else",id:"if--else",level:4},{value:"Switch / case",id:"switch--case",level:4},{value:"Iteration Statements",id:"iteration-statements",level:3},{value:"For Loops",id:"for-loops",level:4},{value:"Foreach Loops",id:"foreach-loops",level:4},{value:"While Loops",id:"while-loops",level:4},{value:"Do-While Loops",id:"do-while-loops",level:4},{value:"Break and Continue",id:"break-and-continue",level:4},{value:"Arrays and Lists",id:"arrays-and-lists",level:2},{value:"Arrays",id:"arrays-1",level:3},{value:"Types of Arrays",id:"types-of-arrays",level:4},{value:"Multi Dimension Arrays",id:"multi-dimension-arrays",level:4},{value:"Syntax (Rectangular Array 2D)",id:"syntax-rectangular-array-2d",level:4},{value:"Syntax (Rectangular Array 3D)",id:"syntax-rectangular-array-3d",level:4},{value:"Syntax (Jagged)",id:"syntax-jagged",level:4},{value:"Lists",id:"lists",level:3},{value:"Arrays vs Lists",id:"arrays-vs-lists",level:4},{value:"Creating a List",id:"creating-a-list",level:4},{value:"Useful Methods",id:"useful-methods",level:4},{value:"Working with Dates",id:"working-with-dates",level:2},{value:"DateTime",id:"datetime",level:3},{value:"TimeSpan",id:"timespan",level:3},{value:"Creating TimeSpan Objects",id:"creating-timespan-objects",level:4},{value:"Reading TimeSpan Object Properties",id:"reading-timespan-object-properties",level:4},{value:"Working with Text",id:"working-with-text",level:2},{value:"String",id:"string",level:3},{value:"StringBuilder",id:"stringbuilder",level:3},{value:"Procedural Programming",id:"procedural-programming",level:3},{value:"Working with Files",id:"working-with-files",level:2},{value:"Introduction to System.IO",id:"introduction-to-systemio",level:3},{value:"File, FileInfo",id:"file-fileinfo",level:4},{value:"Directory, DirectoryInfo",id:"directory-directoryinfo",level:4},{value:"Path",id:"path",level:4},{value:"Path",id:"path-1",level:3},{value:"Debugging Applications",id:"debugging-applications",level:2},{value:"Debugging Tools in Visual Studio",id:"debugging-tools-in-visual-studio",level:3},{value:"Removing Side Effects",id:"removing-side-effects",level:3},{value:"Defensive Programming",id:"defensive-programming",level:3},{value:"Call Stack Window",id:"call-stack-window",level:3},{value:"Locals and Autos Windows",id:"locals-and-autos-windows",level:3}],I={toc:L},W="wrapper";function P(e){let{components:t,...x}=e;return(0,i.kt)(W,(0,a.Z)({},I,x,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"c-basics-part-1"},"C# Basics Part 1"),(0,i.kt)("p",null,"In this tutorial we will learn the basics of C#. This is very high quality tutorial, a comprehensive and deep understanding of C# will be obtained by the end of this 3 part tutorial pages."),(0,i.kt)("h2",{id:"c-vs-net-framework"},"C# vs. .NET Framework"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C# is a programming language (statically typed and object-oriented)"),(0,i.kt)("li",{parentName:"ul"},".NET is a framework for building applications on Windows")),(0,i.kt)("h2",{id:"net-framework"},".NET Framework"),(0,i.kt)("p",null,".NET Framework consist of the following two components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"CLR (Common Language Runtime)"),(0,i.kt)("li",{parentName:"ul"},"Class Library")),(0,i.kt)("h2",{id:"clr-common-language-runtime"},"CLR (Common Language Runtime)"),(0,i.kt)("p",null,"For languages like ",(0,i.kt)("inlineCode",{parentName:"p"},"c/c++")," when we compile the application, the ",(0,i.kt)("strong",{parentName:"p"},"compiler")," translates our code and we get a native machine code. Which means if we write an application in ",(0,i.kt)("inlineCode",{parentName:"p"},"c++")," on Windows machine   with 86x processor architecture, the compiler would translate our code into the native code for that machine. But, we have different hardwares, different operating systems, so if we take that application (compiled program) into a computer with a different operating system and CPU architecture, that would not run. "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"OS Difference",src:n(1969).Z,width:"2135",height:"1075"})),(0,i.kt)("p",null,"So when ",(0,i.kt)("strong",{parentName:"p"},"Microsoft")," was designing the C# language, and the .NET framework, came with an idea that borrowed from Java language, in Java when you compile a program it translates to intermediate language called ",(0,i.kt)("strong",{parentName:"p"},"ByteCode")," and we have the same exact concept in C#."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Just-In-Time-Compilation",src:n(4906).Z,width:"1790",height:"1209"})),(0,i.kt)("p",null,"When we compile a C# application we get a ",(0,i.kt)("strong",{parentName:"p"},"IL")," Code (Intermediate Language) is independent from the computer its running on, then we have something that translate that IL intermediate code into the native machine code. That is the job of then ",(0,i.kt)("strong",{parentName:"p"},"CLR"),", it is an application that sitting in the memory whose job is to translate the IL code into the machine code. This process is called ",(0,i.kt)("strong",{parentName:"p"},"Just-in-time Compilation (JIT)"),". With this architecture, you can write an application in C# and don't have to worry about compiling that into the native code for different machines, as long as the machine has ",(0,i.kt)("strong",{parentName:"p"},"CLR")," that can run your application."),(0,i.kt)("h2",{id:"architecture-of-net-applications"},"Architecture of .NET Applications"),(0,i.kt)("p",null,"Let us learn now about the architecture of .NET applications, at a very high level, when you build an application with C#, your application consist of building blocks called ",(0,i.kt)("strong",{parentName:"p"},"classes"),". These classes collaborate with each other at runtime, and as a result the application provides some functionality. "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:r,width:"50%",alt:".NET Classes"})),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"class")," contains some data (attributes/fields) and some functions (methods/behaviours), data represent the ",(0,i.kt)("u",null,"state")," of the application."),(0,i.kt)("p",null,"Now as the number of classes grows, we need a way to organize these classes, that is where we use a ",(0,i.kt)("strong",{parentName:"p"},"Namespace"),".  A Namespace, is a container for related classes. For example, in the .NET framework, we have namespaces containing tens of related classes, we have namespaces for working with data like databases, we have namespaces for working with graphics and images, we have namespaces for working with security. "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:o,width:"50%",alt:"Namespaces"})),(0,i.kt)("p",null,"Now, in real world applications, as these namespaces grow, we need a different way of partitioning an application and that when we use an ",(0,i.kt)("strong",{parentName:"p"},"Assembly"),". An Assembly, is a container for related namespaces, physically it is a ",(0,i.kt)("strong",{parentName:"p"},"file")," on the disk, which can either be a an ",(0,i.kt)("strong",{parentName:"p"},"executable (EXE)")," or a ",(0,i.kt)("strong",{parentName:"p"},"DLL (Dynamically Linked Library)"),". "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:s,width:"50%",alt:"Assembly"})),(0,i.kt)("p",null,"When you compile your application, the compiler, builds one or more assemblies depending on how you partitioned your code."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:l,width:"50%",alt:"App"})),(0,i.kt)("h2",{id:"primitive-types-and-expressions"},"Primitive Types and Expressions"),(0,i.kt)("p",null,"This section will explore the concepts of  ",(0,i.kt)("strong",{parentName:"p"},"Variables and Constants"),", ",(0,i.kt)("strong",{parentName:"p"},"Data Types"),", ",(0,i.kt)("strong",{parentName:"p"},"Type Conversion and Overflowing"),", ",(0,i.kt)("strong",{parentName:"p"},"Scope"),", ",(0,i.kt)("strong",{parentName:"p"},"Operators")," and ",(0,i.kt)("strong",{parentName:"p"},"Comments"),"."),(0,i.kt)("h3",{id:"variables-and-constants"},"Variables and Constants"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Variable")," is a name given to a storage location in memory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Constant")," is an immutable value")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// General Syntax : <const> <data-type> <identifier> = <value>;\n\n// Declaring Variables and Constants\nint number;\n\n// Initialize Variables\nint Number = 1;\n\nconst float Pi = 3.14f;\n")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Note: that ",(0,i.kt)("strong",{parentName:"p"},"C#")," is a case-sensitive language, meaning these two identifiers ",(0,i.kt)("strong",{parentName:"p"},"number")," and ",(0,i.kt)("strong",{parentName:"p"},"Number")," are different. Also variables ",(0,i.kt)("strong",{parentName:"p"},"must")," be ",(0,i.kt)("u",null,"initialized")," before usage, otherwise you get a compile-time error.")),(0,i.kt)("h4",{id:"identifiers"},"Identifiers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Cannot start with a number"),(0,i.kt)("li",{parentName:"ul"},"Cannot include a whitespace"),(0,i.kt)("li",{parentName:"ul"},"Cannot be a reserved keyword"),(0,i.kt)("li",{parentName:"ul"},"Use meaningful names.")),(0,i.kt)("h4",{id:"naming-conventions"},"Naming Conventions"),(0,i.kt)("p",null,"Some popular variable naming conventions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Camel Case          : ",(0,i.kt)("inlineCode",{parentName:"li"},"firstName")),(0,i.kt)("li",{parentName:"ul"},"Pascal Case         : ",(0,i.kt)("inlineCode",{parentName:"li"},"FirstName")),(0,i.kt)("li",{parentName:"ul"},"Hungarian Notation  : ",(0,i.kt)("inlineCode",{parentName:"li"},"strFirstName")),(0,i.kt)("li",{parentName:"ul"},"Snake Case          : ",(0,i.kt)("inlineCode",{parentName:"li"},"variable_one"))),(0,i.kt)("p",null,"Its usually preferred to use camel case, and avoid hungarian notation."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"CSharp Primitive Types",src:n(3330).Z,width:"1577",height:"641"})),(0,i.kt)("h5",{id:"real-numbers"},"Real Numbers"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"double")," is the default type for floating-point decimal numbers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"float   number = 1.2f; // To tell the compiler to treat the number as a float otherwise it would be double\ndecimal number = 1.2m; \n")),(0,i.kt)("p",null,"To learn more you can google search:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C# built-in types"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://msdn.microsoft.com/en-us/library/cs7y5x0x(v=vs.90).aspx"},"http://msdn.microsoft.com/en-us/library/cs7y5x0x(v=vs.90).aspx"))),(0,i.kt)("h3",{id:"overflowing"},"Overflowing"),(0,i.kt)("p",null,"Now we talk about the concept of ",(0,i.kt)("strong",{parentName:"p"},"overflowing"),". Consider the following code snippet."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"byte number = 255;\n\nnumber = number + 1; // 0\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"255")," is the largest value we can store in a byte. In the second line we are trying to increment number one to have 256. But if you compile and run your application you will see ",(0,i.kt)("inlineCode",{parentName:"p"},"zero (0)"),". This is what we call overflowing. We have exceeded the boundary of the byte data type. In C# by default we don't have overflowing checking, which means we can modify the value of a variable at runtime and if we go beyond the boundary of its underlying data type, we will get overflow. Sometimes this is not desirable in our application and want to stop overflowing, if that is the case we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"checked")," keyword."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"checked \n{\n  byte number = 255;\n\n  number = number + 1; \n}\n")),(0,i.kt)("p",null,"With this code, overflow will not happen at ",(0,i.kt)("strong",{parentName:"p"},"runtime"),", instead an exception will be thrown and the program will crash unless you handle the exception. We will cover exception now, but much later in part 3 of the C# tutorial. In reality this is rarely happens, since if we are concerned about overflow, we simply use a bigger data type such as ",(0,i.kt)("inlineCode",{parentName:"p"},"short")," in this example. There is also the case when the result is smaller than the smallest value that can be stored or represented, these are often called ",(0,i.kt)("strong",{parentName:"p"},"underflows"),"."),(0,i.kt)("h3",{id:"scope"},"Scope"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Where a variable / constant has meaning. Take a look at the following code snippet.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"{\n  byte a = 1;\n  {\n    byte b = 2;\n    {\n      byte c = 3;\n    }\n  }\n}\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"block")," is indicated by a pair of curly braces ",(0,i.kt)("inlineCode",{parentName:"p"},"{}"),".  Here we have three blocks of code, the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is accessible in that block or any child blocks, if you try to access the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," outside of the first block, the program will not compile. The same rule applies to the other variables ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is meaningful in its scope block and any of its children blocks. "),(0,i.kt)("h3",{id:"type-conversions"},"Type Conversions"),(0,i.kt)("p",null,"We will be taking about various kinds of type conversion."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implicit type conversion"),(0,i.kt)("li",{parentName:"ul"},"Explicit type conversion (Casting)"),(0,i.kt)("li",{parentName:"ul"},"Conversion between non-compatible types")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("h4",{parentName:"admonition",id:"implicit-type-conversion"},"Implicit Type Conversion"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"byte b = 1;       //                            000000001\nint i = b;        // 00000000 00000000 00000000 00000001\n")),(0,i.kt)("p",{parentName:"admonition"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"byte")," takes only one byte of memory and an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," takes four bytes of memory. So we can easily copy a byte into an integer. As can be shown from the ",(0,i.kt)("u",null,"binary representation"),", there is no data lose, when the compiler is sure that the data types are compatible and no data loss will happen, values can be converted to a different type ",(0,i.kt)("inlineCode",{parentName:"p"},"implicitly"),"."),(0,i.kt)("p",{parentName:"admonition"},"An example of something that won't compile:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int i = 1;\nbyte b = i; //  won't compile\n")),(0,i.kt)("p",{parentName:"admonition"},"In this example, we declared an integer and we are trying to copy that to a byte, an integer is four bytes, so when we convert that to a byte, three bytes out of four bytes will be gone, and there is a chance for data loss, now ",(0,i.kt)("inlineCode",{parentName:"p"},"data loss")," doesn't always happen, it only happens if the value we stored in the integer is beyond the capacity of a byte, in this example ",(0,i.kt)("inlineCode",{parentName:"p"},"one")," can be stored in a byte, so no data loss will happen, but if we had ",(0,i.kt)("inlineCode",{parentName:"p"},"300")," here, we cannot store ",(0,i.kt)("inlineCode",{parentName:"p"},"300")," in a byte and as a result of that conversion data will be lost. When the compiler knows there is a chance for data loss, it doesn't allow ",(0,i.kt)("inlineCode",{parentName:"p"},"implicit type conversion")," and you need to explicitly tell the compiler that you are aware of the data loss and you still want to go ahead with the conversion.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("h4",{parentName:"admonition",id:"explicit-type-conversion"},"Explicit Type Conversion"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int i = 1;\nbyte b = (byte) i;\n")),(0,i.kt)("p",{parentName:"admonition"},"This is the same as the last example, the only difference is we have prefixed ",(0,i.kt)("inlineCode",{parentName:"p"},"(byte)")," before assigning the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". Which means we are trying to convert ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," into a byte. This is called as ",(0,i.kt)("inlineCode",{parentName:"p"},"casting"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"float f = 1.0f;\nint i = (int)f;\n")),(0,i.kt)("p",{parentName:"admonition"},"Here is another example, casting tells the compiler I am aware of the data loss and still wants to convert ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," which is a float into an integer.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("h4",{parentName:"admonition",id:"non-compatible-types"},"Non-compatible types"),(0,i.kt)("p",{parentName:"admonition"},"Sometimes we have non-compatible types but still need to convert between them."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'string s = "1";\nint i = (int)s; // won\'t compile\n')),(0,i.kt)("p",{parentName:"admonition"},"In this example and similar examples, is where we have a number represented as a string, and we need to convert it to an integer. Since in this situation string and integer are not compatible, we cannot use explicit casting.  "),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'string s  = "1";\nint i     = Convert.ToInt32(s); // Method 1\nint j     = int.Parse(s);       // Method 2\n')),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"Convert")," class is part of the .NET framework, and is defined in Systems namespace. Contains different methods for conversion and they all start with ",(0,i.kt)("inlineCode",{parentName:"p"},"To..."),". The second method is ",(0,i.kt)("inlineCode",{parentName:"p"},"Parse"),", all primitive types have this ",(0,i.kt)("inlineCode",{parentName:"p"},"Parse")," method, and the parse method takes in a string and tried to convert that to the target type. "),(0,i.kt)("p",{parentName:"admonition"},"The following are some of the methods you can use and find in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Convert")," class:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Convert.ToByte  (s);\nConvert.ToInt16 (s);\nConvert.ToInt32 (s);\nConvert.ToInt64 (s);\n"))),(0,i.kt)("p",null,"Sample C# Program using type conversion."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'\nusing System; // Namespace System\n\nnamespace TypeConversion\n{\n  class Program\n  {\n    static void Main(string[] args)\n    {\n      try\n      {\n        string str = "true";\n        bool a = Convert.ToBoolean(str);\n        Console.WriteLine(a);\n\n        // The try-catch for this case.\n        var number = "1234";\n        byte b = Convert.ToByte(number);\n        Console.WriteLine(b);\n      }\n      catch(Exception)\n      {\n        Console.WriteLine("The number could not be converted to a byte.");\n      }\n    }\n  }\n}\n\n\n')),(0,i.kt)("h3",{id:"operators"},"Operators"),(0,i.kt)("p",null,"In C# we have the following five types of operators:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Arithmetic Operators"),(0,i.kt)("li",{parentName:"ul"},"Comparison Operators"),(0,i.kt)("li",{parentName:"ul"},"Assignment Operators"),(0,i.kt)("li",{parentName:"ul"},"Logical Operators"),(0,i.kt)("li",{parentName:"ul"},"Bitwise Operators")),(0,i.kt)("h4",{id:"arithmetic-operators"},"Arithmetic Operators"),(0,i.kt)("p",null,"In computation, when we are working with numbers."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:p,width:"50%",alt:"Arithmetic Operators"})),(0,i.kt)("p",null,"We also have two arithmetic operators called ",(0,i.kt)("inlineCode",{parentName:"p"},"increment")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"decrement"),"."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:m,width:"50%",alt:"Arithmetic Operators 2"})),(0,i.kt)("p",null,"Which are shortcuts for adding or subtracting one. Note, with this increment and decrement operators, there are two ways in which you can apply them. ",(0,i.kt)("inlineCode",{parentName:"p"},"Postfix Increment")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Prefix Increment"),". "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Postfix Increment\nint a = 1;\nint b = a++; // b = 1, a = 2;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Prefix Increment\nint a = 1;\nint b = ++a; // b = 2, a = 2;\n")),(0,i.kt)("h4",{id:"comparison-operators"},"Comparison Operators"),(0,i.kt)("p",null,"Comparing values, can be accomplished using comparison operators."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:c,width:"50%",alt:"Comparison Operators"})),(0,i.kt)("p",null,"Note the difference between the assignment operator ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," and the equality check ",(0,i.kt)("inlineCode",{parentName:"p"},"=="),"."),(0,i.kt)("h4",{id:"assignment-operators"},"Assignment Operators"),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:d,width:"50%",alt:"Assignment Operators"})),(0,i.kt)("h4",{id:"logical-operators"},"Logical Operators"),(0,i.kt)("p",null,"Logical operators are used in ",(0,i.kt)("strong",{parentName:"p"},"boolean expressions")," which are often used in conditional statements."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:u,width:"50%",alt:"Logical Operators"})),(0,i.kt)("h4",{id:"bitwise-operators"},"Bitwise Operators"),(0,i.kt)("p",null,"These are often used in low-level programming. For example, when working with ",(0,i.kt)("inlineCode",{parentName:"p"},"Win32")," api or sockets or encryption. "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:h,width:"50%",alt:"Bitwise Operators"})),(0,i.kt)("h3",{id:"boolean-algebra"},"Boolean Algebra"),(0,i.kt)("p",null,"Logical operators are part of Boolean algebra, the value of variables can only be ",(0,i.kt)("strong",{parentName:"p"},"true")," or ",(0,i.kt)("strong",{parentName:"p"},"false"),", also denoted 1 or 0 respectively. Unlike elementary algebra, where the main operations are addition, subtraction, etc, the main operations of Boolean Algebra are ",(0,i.kt)("strong",{parentName:"p"},"conjunction")," (AND), ",(0,i.kt)("strong",{parentName:"p"},"disjunction")," (OR) and ",(0,i.kt)("strong",{parentName:"p"},"negation")," (NOT)."),(0,i.kt)("h4",{id:"logical-and"},"Logical AND"),(0,i.kt)("p",null,"Let\u2019s assume we have two variables: ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y"),". In C#, the logical AND operator is indicated by &&. We can define a Boolean expression as follows:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"z = x && y")),(0,i.kt)("p",null,"In this expression, ",(0,i.kt)("strong",{parentName:"p"},"z")," is true if both ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y")," are true; otherwise, it\u2019ll be false."),(0,i.kt)("p",null,"What is a real-world example of this in programming? Imagine you\u2019re developing a loan application. The provider only offers loans to applicants who are over 18 and are citizen of the given country. In this example, we have two variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"x = applicant being over 18\ny = application being a citizen\nz = is eligible to apply for loan = x && y\n")),(0,i.kt)("p",null,"If both ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y")," are true, the applicant is eligible to apply for a loan. Later, when we get to conditional statements, you can check to see if the above expression evaluates to true or false, and then, can change the flow of your application. "),(0,i.kt)("p",null,"So, here is the rule of thumb with logical AND: if both ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y")," are true, ",(0,i.kt)("strong",{parentName:"p"},"x && y")," will be true; otherwise, it\u2019ll be false"),(0,i.kt)("h4",{id:"logical-or"},"Logical OR"),(0,i.kt)("p",null,"In C#, logical OR is indicated by two vertical lines (||). Considering the following expression:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"z = x || y")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"z")," will be true, if either ",(0,i.kt)("strong",{parentName:"p"},"x")," or ",(0,i.kt)("strong",{parentName:"p"},"y")," is true."),(0,i.kt)("p",null,"What is a real-world example of this? Imagine you're building software for a recruiter. For a given job application, applicants can apply if they have a degree in computing, or more than 5 years of experience in the field. You can model this using a Boolean expression as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"x = applicant has a degree in computing\ny = applicant has more than 5 years of experience\n\nz = application is eligible = x || y\n")),(0,i.kt)("p",null,"If either x or y is true, z will be true."),(0,i.kt)("p",null,"So, unlike the logical AND, where both variables must be true, with logical OR, if at least one of them is true, the result will be true."),(0,i.kt)("h4",{id:"logical-not"},"Logical NOT"),(0,i.kt)("p",null,"The NOT operator in C# is indicated by an exclamation mark (!) and it reverse or flip the value of a given variable or expression."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"y = !x")),(0,i.kt)("p",null,"so, here, if ",(0,i.kt)("strong",{parentName:"p"},"x")," is true, ",(0,i.kt)("strong",{parentName:"p"},"y")," will be false,  and if ",(0,i.kt)("strong",{parentName:"p"},"x")," is false, ",(0,i.kt)("strong",{parentName:"p"},"y")," will be true."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("h2",{parentName:"admonition",id:"clean-coding"},"Clean Coding"),(0,i.kt)("p",{parentName:"admonition"},"In all examples, here, I used variables ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y"),", mainly to relate programming to Boolean algebra. But when it comes to coding, you should avoid using variable names such as x, y, z as they don't give a clue to other developers reading your code (or even yourself). Instead, use meaningful names. For instance, in the first example, you can replace ",(0,i.kt)("strong",{parentName:"p"},"x"),", ",(0,i.kt)("strong",{parentName:"p"},"y"),", and ",(0,i.kt)("strong",{parentName:"p"},"z")," as follows:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"x : isOver18\ny : isCitizen\nz : isEligible\n")),(0,i.kt)("p",{parentName:"admonition"},"often, it's a good practice to prefix Boolean names with IS or HAS (if possible).")),(0,i.kt)("h3",{id:"comments"},"Comments"),(0,i.kt)("p",null,"A text we put into our code to improve its readability and maintainability. In C# we have two ways to write comments. "),(0,i.kt)("h4",{id:"single-line-comment"},"Single-line Comment"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Here is a single-line comment\nint a = 1;\n")),(0,i.kt)("h4",{id:"multi-line-comments"},"Multi-line Comments"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"/*\n  Here is a multi-line\n  comment\n*/\nint a = 1;\n")),(0,i.kt)("h4",{id:"when-to-use"},"When to use"),(0,i.kt)("p",null,"To explain whys, hows, constrains, etc. not the whats. Keep your comments to a minimum, use only when required. Do not explain what the code is doing, your code should be so clean and straight forward, that it does not need comments.  If the comment is just explaining what the code is doing, then its redundant and the problem with redundant comments is we change the code but not everyone is very consistent in changing the comments, so after a while the comments become out-dated and there is no way to validate them and after a while they become useless."),(0,i.kt)("h2",{id:"non-primitive-types"},"Non-Primitive Types"),(0,i.kt)("p",null,"In this section we will be taking about the non-primitive data structures of C#. Such as ",(0,i.kt)("strong",{parentName:"p"},"Classes"),", ",(0,i.kt)("strong",{parentName:"p"},"Structures"),",  ",(0,i.kt)("strong",{parentName:"p"},"Arrays"),", ",(0,i.kt)("strong",{parentName:"p"},"Strings")," and ",(0,i.kt)("strong",{parentName:"p"},"Enums"),".  Then will discuss important topics of ",(0,i.kt)("inlineCode",{parentName:"p"},"reference types vs value types")," which are about memory management of different types in C# language."),(0,i.kt)("h3",{id:"classes"},"Classes"),(0,i.kt)("p",null,"Classes are the building blocks of our applications. Class combines related variables (fields) amd functions (methods). "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:g,width:"50%",alt:"Classes"})),(0,i.kt)("p",null,"A class is a ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"blueprint")," from which we create ",(0,i.kt)("strong",{parentName:"p"},"objects"),". An object is an ",(0,i.kt)("strong",{parentName:"p"},"instance")," of a class. When you run your applications, its the objects that talk to each other and collaborating to provide some functionality."),(0,i.kt)("p",null,"To create a class in C# we start with an ",(0,i.kt)("strong",{parentName:"p"},"access modifier")," then the class keyword and an Identifier."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public class Person\n{\n  public string Name;\n\n  public void Introduce()\n  {\n    Console.WriteLine("Hi, my name is " + Name);\n  }\n}\n')),(0,i.kt)("p",null,"Public makes the class accessible from anywhere in your application. We declare the variables inside the class scope block, they are called fields and also require access modifier. We can also define methods, in this case we have a method that does not return anything and that takes no arguments. It just outputs the name of the person on the console."),(0,i.kt)("p",null,"Here is another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Calculator\n{\n  public int Add(int a, int b)\n  {\n    return a + b;\n  }\n}\n")),(0,i.kt)("p",null,"A calculator class with one method that takes two integers and return an integer."),(0,i.kt)("h4",{id:"creating-objects"},"Creating Objects"),(0,i.kt)("p",null,"Creating objects, or instances of classes, we need to allocate memory for the new object. They are treated different than primitive types. But unlike other languages like ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"c++"),", you don't have to worry about ",(0,i.kt)("inlineCode",{parentName:"p"},"deallocating")," that memory. CLR (Common Language Runtime) will take care of that for you, it has a process called ",(0,i.kt)("strong",{parentName:"p"},"garbage collection")," which automatically removes all objects that are not used. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Person person = new Person();\n")),(0,i.kt)("p",null,"To allocate memory to a new object on the heap, we use the ",(0,i.kt)("strong",{parentName:"p"},"new")," operator and repeat the type of the class and parenthesis.  We can use this code shorter by using the ",(0,i.kt)("strong",{parentName:"p"},"var")," keyword, which let the compiler determine the type of the variable at compile-time, you can thing of ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," in C++."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'var person = new Person();\n\n// Access object members\nperson.Name = "Mohammed";\nperson.Introduce();\n')),(0,i.kt)("h4",{id:"static-modifier"},"Static Modifier"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Calculator\n{\n  public static int Add(int a, int b)\n  {\n    return a + b;\n  }\n}\n")),(0,i.kt)("p",null,"We have added the ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," keyword to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Add(...)")," method and as a result we can access this method directly from the class without creating an instance or object. the Add() method is a static member, and we can't access static members from objects."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int result = Calculator.Add(1,2);\n")),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:k,width:"50%",alt:"Static Modifier"})),(0,i.kt)("p",null,"Without static modifier, when we create let say three objects of the type Calculator class, each object in the member will have the add method.  But when you apply the static modifier, that method will be in only one place in memory. And that is the calculator class itself. So it will not be repeated three times in memory."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:f,width:"50%",alt:"Static Modifier 2"})),(0,i.kt)("p",null,"Why do we need this, we use the static modifier when we represent a concept that a single instance of that should exist in memory.  For example, the program ",(0,i.kt)("strong",{parentName:"p"},"entry point")," main function, is static. Which means there is only one instance of the main method in memory, there is only one entry point in C#. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class Program\n{\n  static void Main()\n  {\n  }\n}\n")),(0,i.kt)("h3",{id:"structs"},"Structs"),(0,i.kt)("p",null,"C# has something similar to classes called ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," for structure. Which is a bundle of data, you can think of it a memory region. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public struct RgbColor\n{\n  public int Red;\n  public int Green;\n  public int Blue;\n}\n")),(0,i.kt)("p",null,"Combine related fields and methods together, although its similar to classes but has distinct differences. Use a structure when you want to define a small lightweight object. E.g. rgb color, a point. Its more efficient for having multiple small objects, like 1000 points or colors."),(0,i.kt)("h3",{id:"arrays"},"Arrays"),(0,i.kt)("p",null,"Another non-primitive type we have in C# is array. The following section will introduce the basics of arrays in C#, later we will go more in depth. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Array")," A data structure to store a collection of variables of the same type."),(0,i.kt)("h4",{id:"declaring-arrays"},"Declaring Arrays"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int number1;\nint number2;\nint number3;\n\nint[] numbers = new int[3];\n")),(0,i.kt)("p",null,"Imagine you want to work with three numbers, instead of having three different variables, you can define a variable array that can work with three numbers. You need to allocate memory and is an object behind the scene, the compiler creates an instance of the Array class."),(0,i.kt)("h4",{id:"accessing-array-elements"},"Accessing Array Elements"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int[] numbers = new int[3];\n\nnumbers[0] = 1;\nnumbers[1] = 2;\nnumbers[2] = 3;\n\n")),(0,i.kt)("p",null,"Note in C# arrays are ",(0,i.kt)("inlineCode",{parentName:"p"},"zero-indexed")," which means the first element in the array start at index 0. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// If you know the values before hand you can use the object initializer list and make the code shorter\nint[] numbers = new int[3] {1,2,3};\n")),(0,i.kt)("h3",{id:"strings"},"Strings"),(0,i.kt)("p",null,"In this section will explore the following topics, later on, we will learn more about strings:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"What is a string"),(0,i.kt)("li",{parentName:"ul"},"How to create strings"),(0,i.kt)("li",{parentName:"ul"},"Escape characters and verbatim strings")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"string")," is a sequence of characters. e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},'"Hello World"'),"."),(0,i.kt)("h4",{id:"creating-strings"},"Creating Strings"),(0,i.kt)("p",null,"There are many ways to create strings in C#."),(0,i.kt)("p",null,"Using String Literals."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'string firstName = "Mohammed";\nstring lastName = "Fajer";\n')),(0,i.kt)("p",null,"Using String Concatenation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'string name = firstName + " " + lastName;\n')),(0,i.kt)("p",null,"Sometimes it can be hard if you are using string concatenation to determine what is what, so there is another way to concatenate strings that can be more suitable in certain sitatuins."),(0,i.kt)("p",null,"Using String Formats"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'string name = string.Format("{0} {1}", firstName, lastName);\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Format(...)")," is a static method of the string class."),(0,i.kt)("p",null,"Using String Join"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'var numbers = new int[3] {1,2,3};\nstring list = string.Join(",", numbers); // 1,2,3\n')),(0,i.kt)("p",null,"Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Join(...)")," static method of the string class passing the separator and the list of numbers to combine."),(0,i.kt)("h4",{id:"string-elements"},"String Elements"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"string name = \"Mohammed\";\nchar firstChar = name[0];\n\nname[0] = 'm'; // will not be compiled. not allowed as strings are immutable.\n\n")),(0,i.kt)("h4",{id:"strings-are-immutable"},"Strings are Immutable"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Once you create them, you cannot change them.")),(0,i.kt)("h4",{id:"escape-characters"},"Escape Characters"),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:y,width:"50%",alt:"Escape Characters"})),(0,i.kt)("p",null,"There are special characters that have different meanings. Escaping special characters using ",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),". "),(0,i.kt)("h4",{id:"verbatim-strings"},"Verbatim Strings"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'string path = "c:\\\\projects\\\\project1\\\\folder1"; // Looks messy\n\n// Verbatim Strings\nstring newPath = @"c:\\projects\\project1\\folder1";\n')),(0,i.kt)("h3",{id:"enums"},"Enums"),(0,i.kt)("p",null,"Another type is Enum, it is a data type that represent a set of name/value pairs (constants). "),(0,i.kt)("p",null,"Example: Imagine you are building an application for post company and want to support few different shipping methods."),(0,i.kt)("p",null,"One way you can declare a few constants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"const int RegularAirMail = 1;\nconst int RegisteredAirMail = 2;\nconst int Express = 3;\n")),(0,i.kt)("p",null,"each representing a shipping method, and in your application based on the shipping method, you can make decisions to calculate the shipping cost, or the tax or display different messages to the user, so possibilities are endless. Even though this approach works, its a little bit messy. It is better to define a new type, where we can represent different shipping methods so that where we use an ",(0,i.kt)("strong",{parentName:"p"},"Enum"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public enum ShippingMethod\n{\n  RegularAirMail = 1,\n  RegisteredAirMail = 2,\n  Express = 3\n}\n")),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"enums")," where you have a number of related constants. Instead of declaring multiple constants, declare an enum, this will be a new type in our applications, just like classes or structures. We can use enum with the ",(0,i.kt)("inlineCode",{parentName:"p"},".")," dot notation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var method = ShippingMethod.Express;\n")),(0,i.kt)("p",null,"Note: enum internally is an integer but if you have a reason to change that, then you can specify that type during declaration  of your enum."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public enum ShippingMethod : byte\n{\n  RegularAirMail = 1,\n  RegisteredAirMail = 2,\n  Express = 3\n}\n")),(0,i.kt)("p",null,"Example Program Using Enum."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using System;\n\nnamespace CSharpFundamentals\n{\n  // by default set to zero, and the next are incremented by one\n  public enum ShippingMethod\n  {\n    RegularAirMail = 1, \n    RegisteredAirMail = 2,\n    Express = 3\n  }\n\n  class Program\n  {\n    static void Main(string[] args)\n    {\n      // Using Integers\n      var method = ShippingMethod.Express;\n      Console.WriteLine((int)method); // Casting \n\n      var methodId = 3;\n      Console.WriteLine((ShippingMethod)methodId); // Express\n\n      // Using strings\n      Console.WriteLine(method.ToString()); // Express\n      Console.WriteLine(method); // Console.WriteLine calls method ToString method.\n\n      var methodName = "Express";\n      ShippingMethod shippingMethod = (ShippingMethod) Enum.Parse(typeof(ShippingMethod), methodName);\n    }\n  }\n}\n\n')),(0,i.kt)("h3",{id:"reference-types-and-value-types"},"Reference Types and Value Types"),(0,i.kt)("p",null,"In C# we have two main types in which we create new types. We have ",(0,i.kt)("inlineCode",{parentName:"p"},"classes")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"structures"),". All primitive types are structures, custom structures. Arrays, Strings are classes, custom classes. They are treated differently at runtime in terms of memory management."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:w,width:"50%",alt:"Reference and Value Types"})),(0,i.kt)("p",null,"  Structures are what we call ",(0,i.kt)("strong",{parentName:"p"},"value types")," and classes are ",(0,i.kt)("strong",{parentName:"p"},"reference types"),". Value types are allocated on the stack memory section at compile time. This memory allocation done automatically, immediately removed when out of scope by runtime or CLR. With reference types, the programmer is responsible for allocation at runtime, memory is allocated on the heap section of memory, through the process of garbage collection by runtime or CLR, all unused object and reference types get cleaned after some time by this process."),(0,i.kt)("h4",{id:"copying-value-types"},"Copying Value Types"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using System;\n\nnamespace CSharpFundamentals\n{\n  public struct Coords \n  {\n    public int X;\n    public int Y;\n\n    public Coords(int x, int y)\n    {\n      X = x;\n      Y = y;\n    }\n\n    public override string ToString() => $"({X}, {Y})";\n  }\n\n  class Program\n  {\n    static void Main(string[] args)\n    {\n      var a = new Coords(1,2);\n      var b = a;\n      b.X = 66;\n      Console.WriteLine(a); // (1, 2)\n      Console.WriteLine(b); // (66, 2)\n    }\n  }\n}\n\n')),(0,i.kt)("p",null,"As you can see from the above example, since structure is a value type, a was copied into b. This is known as a value type assignment, where the values of the fields in ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," are copied to the corresponding fields in ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". This behavior is due to the fact we are using value types in C#. Value types hold their data directly and are stored on the stack, example include, primitive types (int, float, etc.) and structs. Another important note is the use of ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," keyword with structures, even though we have used the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," keyword when creating instances of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Coords")," structure, structs are still value types. The ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," keyword is used to call the constructor of a struct, but the memory allocation and management behavior for structs remains that of value types (stack allocation)."),(0,i.kt)("h2",{id:"control-flow"},"Control Flow"),(0,i.kt)("p",null,"In this section will explore conditional and iteration statements in C#. We use these statements to control the ",(0,i.kt)("inlineCode",{parentName:"p"},"flow")," of the program."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:b,width:"50%",alt:"Reference and Value Types"})),(0,i.kt)("h3",{id:"conditional-statements"},"Conditional Statements"),(0,i.kt)("p",null,"We will take a look at C# language constructs that are used for controlling the program execution. The following constructs will be explored:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If / else statements"),(0,i.kt)("li",{parentName:"ul"},"Switch / case statements"),(0,i.kt)("li",{parentName:"ul"},"Conditional operator : A ? B : C")),(0,i.kt)("h4",{id:"if--else"},"If / else"),(0,i.kt)("p",null,"A basic structure looks something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"if(condition)\n  someStatement\n\nelse if(anotherCondition)\n  anotherStatement\n\nelse\n  yetAnotherStatement\n")),(0,i.kt)("p",null,"The statements in the ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"else if")," are only executed if the conditions are true in that case. The ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," is executed if none of the conditions before were true. "),(0,i.kt)("p",null,"If we have one or more than one line of code we need to enclose them with curly braces:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"if(condition)\n{\n  someStatements\n}\nelse\n{\n  otherStatements\n}\n")),(0,i.kt)("p",null,"Another thing, we can do is ",(0,i.kt)("inlineCode",{parentName:"p"},"nest")," if statements together called nested-if statements."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"if(condition)\n{\n  if(anotherCondition)\n    ...\n  else\n    ...\n}\n")),(0,i.kt)("p",null,"Generally, its a bad practice to use multiple nested if statements as it result in code that is hard to read, hard to understand, hard to maintain and hard to test, that is what we call a ",(0,i.kt)("strong",{parentName:"p"},"code smell")," and that is something you should avoid at all times."),(0,i.kt)("h4",{id:"switch--case"},"Switch / case"),(0,i.kt)("p",null,"Switch is slightly different than if, ",(0,i.kt)("inlineCode",{parentName:"p"},"if statements")," we usually have a condition that is evaluated and if its true, some piece of code will be executed, With switch however, we have a variable that we compare its value with different values. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"switch(role)\n{\n  case Role.Admin:\n    ...\n    break;\n  case Role.Moderator:\n    ...\n    break;\n  default:\n    ...\n    break;\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," statement is terminated by ",(0,i.kt)("strong",{parentName:"p"},"break")," statement. If none of the cases is true, then the default block/case is executed. ")),(0,i.kt)("h3",{id:"iteration-statements"},"Iteration Statements"),(0,i.kt)("p",null,"Iteration statements are used for repeatedly executing a sequence of statements. In C# there is four iteration statements:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For loops"),(0,i.kt)("li",{parentName:"ul"},"Foreach loops"),(0,i.kt)("li",{parentName:"ul"},"While loops"),(0,i.kt)("li",{parentName:"ul"},"Do-While loops")),(0,i.kt)("p",null,"Let us now examine the syntax of each iteration construct."),(0,i.kt)("h4",{id:"for-loops"},"For Loops"),(0,i.kt)("p",null,"For loops has three parts ",(0,i.kt)("inlineCode",{parentName:"p"},"<initialization clause> ; <condition clause> ; <iteration clause (increment/decrement) counter variable>"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"for(var i = 0; i < 10; i++)\n{\n  ...\n}\n")),(0,i.kt)("h4",{id:"foreach-loops"},"Foreach Loops"),(0,i.kt)("p",null,"Foreach is used to iterate over elements of an enumerable object. What does ",(0,i.kt)("inlineCode",{parentName:"p"},"enumerable")," means ?  in plain language, anything that has some kind of list or array nature. For example, strings are a sequence of characters, so strings are enumerable, the array type also enumerable. We can do that with for loop but with foreach is easier and cleaner. The syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"<local variable> in <list or object we are iterating>"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"int[] numbers = new int[3] {1,2,3};\nforeach (var number in numbers)\n{\n  ...\n}\n")),(0,i.kt)("h4",{id:"while-loops"},"While Loops"),(0,i.kt)("p",null,"In C# we also have while loops."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The syntax looks something like:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"<initialization clause>\nwhile (<condition clause>)\n{\n  ...\n  <iteration clause (increment/decrement) to get closer to condition>\n}\n"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"while(i < 10)\n{\n  ...\n  i++;\n}\n")),(0,i.kt)("p",null,"As long as the condition is valid, the loop will execute."),(0,i.kt)("h4",{id:"do-while-loops"},"Do-While Loops"),(0,i.kt)("p",null,"Finally we have the do-while loop. This is exactly similar to the while loop with one key difference, the loop body is guaranteed to execute at least once because the condition is evaluated at the end of the while loop."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"do\n{\n  ...\n  i++;\n} while (i < 10);\n")),(0,i.kt)("h4",{id:"break-and-continue"},"Break and Continue"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Break")," jumps out of the loop."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Continue")," jumps to the next iteration.")),(0,i.kt)("h2",{id:"arrays-and-lists"},"Arrays and Lists"),(0,i.kt)("p",null,"At this point you know a little bit about arrays, in this section we will expand our knowledge about arrays and introduce you to multi-dimensional arrays. This is useful when working with structures such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Matrix"),". We are also going to introduce a ",(0,i.kt)("inlineCode",{parentName:"p"},"generic list")," which are very useful in building real-world applications."),(0,i.kt)("h3",{id:"arrays-1"},"Arrays"),(0,i.kt)("p",null,"In this section we will cover the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Quick review of arrays"),(0,i.kt)("li",{parentName:"ul"},"Types of Arrays in C#"),(0,i.kt)("li",{parentName:"ul"},"Array methods")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Array")," represent a fixed number of variables of a particular type. "),(0,i.kt)("h4",{id:"types-of-arrays"},"Types of Arrays"),(0,i.kt)("p",null,"In C# there are two types of arrays ",(0,i.kt)("inlineCode",{parentName:"p"},"single dimension")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"multi dimension"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var numbers = new int[5];\n\n// Object Initialization Syntax\nvar numbers = new int[5] {1,2,3,4,5}; // If we know ahead of time the values we want to store.\n")),(0,i.kt)("h4",{id:"multi-dimension-arrays"},"Multi Dimension Arrays"),(0,i.kt)("p",null,"We have two types of multi-dim arrays in C#. ",(0,i.kt)("inlineCode",{parentName:"p"},"Rectangular")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Jagged")," arrays. In ",(0,i.kt)("inlineCode",{parentName:"p"},"Jagged")," arrays the number of columns in each row can be different. A different way to look at ",(0,i.kt)("inlineCode",{parentName:"p"},"Jagged")," arrays as array of arrays. In ",(0,i.kt)("inlineCode",{parentName:"p"},".NET")," CLR is optimized around single dimensional arrays. "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:v,width:"50%",alt:"Multi Dimension Arrays"})),(0,i.kt)("h4",{id:"syntax-rectangular-array-2d"},"Syntax (Rectangular Array 2D)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var matrix = new int[3, 5]; // 3 rows and each row has 5 columns\n")),(0,i.kt)("p",null,"If we know the values we would like to store into this array ahead of time, we can initialize this array using object initialization list as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var matrix = new int[3,5]\n{\n  {1,2,3,4,5},\n  {6,7,8,9,10},\n  {11,12,13,14,15}\n};\n")),(0,i.kt)("p",null,"To access an element in this array, we use index bracket:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var element = matrix[0,0];\n")),(0,i.kt)("h4",{id:"syntax-rectangular-array-3d"},"Syntax (Rectangular Array 3D)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var colors = new int [3, 5, 4]; // 3x5x4\n")),(0,i.kt)("h4",{id:"syntax-jagged"},"Syntax (Jagged)"),(0,i.kt)("p",null,"To create the following Jagged array:"),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:N,width:"30%",alt:"Jagged Arrays"})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var array = new int[3][];\n\narray [0] = new int [4];\narray [1] = new int [5];\narray [2] = new int [3];\n\n// To access an element in that array\narray[0][0] = 1;\n")),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"C#")," all arrays map to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," type that is defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"System")," namespace of ",(0,i.kt)("inlineCode",{parentName:"p"},".NET Framework"),". The array type is a class, it has a bunch of ",(0,i.kt)("inlineCode",{parentName:"p"},"properties")," and methods as shown in the image below."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:C,width:"30%",alt:"Array Type"})),(0,i.kt)("p",null,"Example Code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System;\n\npublic class Program\n{\n  public static void Main(string[] args)\n  {\n    var numbers = new[] {3, 7, 9, 2, 14, 6};\n\n    // Length Property\n    Console.WriteLine("Length : " + numbers.Length);\n\n    // IndexOf() method\n    var index = Array.IndexOf(numbers, 9);\n    Console.WriteLine("Index of 9: " + index);\n\n    // Clear() method\n    Array.Clear(numbers, 0, 2);\n\n    Console.WriteLine("Effect of Clear()"); // The first two elements are set to zero.s\n    foreach(var n in numbers) \n    {\n      Console.WriteLine(n);\n    }\n\n    // Copy() method\n    var anotherArray = new int[3];\n    Array.Copy(numbers, anotherArray, 3); // Copy the first 3 elements from array to anotherArray\n\n    Console.WriteLine("Effect of Copy()"); // 0 0 9\n    foreach(var n in anotherArray) \n      Console.WriteLine(n);\n\n    // Sort() method\n    Array.Sort(numbers);\n    Console.WriteLine("Effect of Sort()"); // 0 0 2 6 9 14\n    foreach(var n in numbers) \n      Console.WriteLine(n);\n\n    // Reverse() method\n    Array.Reverse(numbers);\n    Console.WriteLine("Effect of Reverse()"); // 14 9 6 2 0 0\n    foreach(var n in numbers) \n      Console.WriteLine(n);\n  }\n}\n')),(0,i.kt)("h3",{id:"lists"},"Lists"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"List")," in C# is a dynamic array. Up until now we had arrays for working with fixed number of objects. In some cases you are not sure how many of those objects you are going to be working with and that where we use a ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),". "),(0,i.kt)("h4",{id:"arrays-vs-lists"},"Arrays vs Lists"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Array : ",(0,i.kt)("inlineCode",{parentName:"li"},"Fixed size")),(0,i.kt)("li",{parentName:"ul"},"List  : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dynamic size"))),(0,i.kt)("h4",{id:"creating-a-list"},"Creating a List"),(0,i.kt)("p",null,"List is a generic type ",(0,i.kt)("inlineCode",{parentName:"p"},"<type>")," and you have to specify generic parameters, we will explain generics in part 3 of this C# Basics Tutorial. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var numbers = new List<int>();\n")),(0,i.kt)("p",null,"If we know ahead of time some of the objects we would like to store in the list. We can initialize the list using object initialization syntax."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var numbers = new List<int> () {1, 2, 3, 4};\n")),(0,i.kt)("h4",{id:"useful-methods"},"Useful Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Add()")," "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AddRange()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Remove()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RemoveAt()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"IndexOf()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LastIndexOf()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Contains()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Count"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System.Collections.Generic;\n\npublic class Program\n{\n  public static void Main(string[] args)\n  {\n    var numbers =  new List<int> () { 1, 2, 3, 4 };\n    numbers.Add(1);\n    numbers.AddRange(new int[3] {5, 6, 7});\n\n    foreach(var number in numbers)\n      Console.WriteLine(number);\n    \n    Console.WriteLine();\n    Console.WriteLine("Index of 1: " + numbers.IndexOf(1));\n    Console.WriteLine("Last Index of 1: " + numbers.LastIndexOf(1));\n\n    Console.WriteLine("Count: " + numbers.Count);\n\n    for(var i = 0; i < numbers.Count; i++)\n    {\n      if(numbers[i] == 1)\n        numbers.Remove(numbers[i]);\n    }\n\n    foreach(var number in numbers)\n      Console.WriteLine(number);\n\n    numbers.Clear();\n    Console.WriteLine("Count : " + numbers.Count);\n  } \n}\n')),(0,i.kt)("h2",{id:"working-with-dates"},"Working with Dates"),(0,i.kt)("p",null,"In this section will learn how to work with ",(0,i.kt)("inlineCode",{parentName:"p"},"dates")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"times")," in C#. We will introduce two new types in .NET, ",(0,i.kt)("strong",{parentName:"p"},"DateTime")," and ",(0,i.kt)("strong",{parentName:"p"},"TimeSpan"),"."),(0,i.kt)("h3",{id:"datetime"},"DateTime"),(0,i.kt)("p",null,"This is a structured defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"System")," namespace."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System;\n\nnamespace CSharpFundamentals\n{\n  class Program\n  {\n    static void Main(string[] args)\n    {\n      var dateTime = new DateTime(2023, 8, 31); // Constructor has many overloads\n      var now = DateTime.Now;\n      var today =  DateTime.Today;\n\n      Console.WriteLine("Hour : " + now.Hour);\n      Console.WriteLine("Minute : " + now.Minute);\n\n      // They are immutable, once created, can\'t change.\n\n      // To Modify them, use Add(..).. methods.\n\n      var tomorrow = now.AddDays(1); \n      var yesterday = now.AddDays(-1);\n\n      // String Formatting \n      Console.WriteLine(now.ToLongDateString());\n      Console.WriteLine(now.ToShortDateString());\n      Console.WriteLine(now.ToLongTimeString());\n      Console.WriteLine(now.ToShortTimeString());\n\n      Console.WriteLine(now.ToString("yyyy-MM-dd HH:mm")); // You can pass format specifier to this method\n\n    }\n  }\n}\n')),(0,i.kt)("p",null,"To learn more about ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime"),", you can google search :"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C# datetime format specifier ")),(0,i.kt)("h3",{id:"timespan"},"TimeSpan"),(0,i.kt)("p",null,"This type represent a length of time. There are different ways to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"TimeSpan")," but simplest one is to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," operator."),(0,i.kt)("h4",{id:"creating-timespan-objects"},"Creating TimeSpan Objects"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System;\n\nusing CSFundamentals;\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    // 1 hr, 2 mins, 3 seconds\n    var timeSpan = new TimeSpan(1, 2, 3) ; // Has multiple overloads\n\n    var timeSpan1 = new TimeSpan(1,0,0);\n    var timeSpan2 = TimeSpan.FromHours(1);\n\n    // DateTime - DateTime = TimeSpan Object\n    var start = DateTime.Now;\n    var end = DateTime.Now.AddMinutes(2);\n    var duration = end - start; // TimeSpan \n\n    Console.WriteLine("Duration : " + duration); // 00:02::00.0010000\n  }\n} \n')),(0,i.kt)("h4",{id:"reading-timespan-object-properties"},"Reading TimeSpan Object Properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System;\n\nusing CSFundamentals;\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    // ...\n    var timeSpan = new TimeSpan(1,2,3); // Also immutable\n\n    // Properties\n    Console.WriteLine("Minutes : " + timeSpan.Minutes);\n    Console.WriteLine("Total Minutes : " + timeSpan.TotalMinutes); \n\n    // Add \n    Console.WriteLine("Add Example : " + timeSpan.Add(TimeSpan.FromMinutes(8)));\n    Console.WriteLine("Subtract Example : " + timeSpan.Subtract(TimeSpan.FromMinutes(2)));\n\n    // ToString\n    Console.WriteLine("ToString :" + timeSpan.ToString());\n\n    // Parse\n    Console.WriteLine("Parse: " + TimeSpan.Parse("01:02:03")); // Automatically applies ToString on the TimeSpan Object\n  }\n} \n')),(0,i.kt)("h2",{id:"working-with-text"},"Working with Text"),(0,i.kt)("h3",{id:"string"},"String"),(0,i.kt)("h3",{id:"stringbuilder"},"StringBuilder"),(0,i.kt)("h3",{id:"procedural-programming"},"Procedural Programming"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Procedural Programming")," is a Programming paradigm based on procedure calls. By procedure, it means, ",(0,i.kt)("inlineCode",{parentName:"p"},"function"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"method"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"routine"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"subroutine"),".  A way to break large programs into small methods, or procedures, and organize functionality that way, to help manage the complexity of the program."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Object-Oriented Programming")," A programming paradigm based on objects and message passing."),(0,i.kt)("h2",{id:"working-with-files"},"Working with Files"),(0,i.kt)("p",null,"In this section will learn how to work with ",(0,i.kt)("inlineCode",{parentName:"p"},"files")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"directories")," in C#. We will introduce few useful classes in .NET (File, FileInfo, Directory, DirectoryInfo and Path)."),(0,i.kt)("h3",{id:"introduction-to-systemio"},"Introduction to System.IO"),(0,i.kt)("p",null,"We will take a look on how to work with files and directories in C#. Under the namespace ",(0,i.kt)("inlineCode",{parentName:"p"},"System.IO")," we have the following classes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"File"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"FileInfo")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Directory"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"DirectoryInfo")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Path"))),(0,i.kt)("p",null,"There are many more classes in ",(0,i.kt)("inlineCode",{parentName:"p"},".NET"),", no one in the world, knows everything single class in ",(0,i.kt)("inlineCode",{parentName:"p"},".NET"),", you will discover classes based on your needs."),(0,i.kt)("h4",{id:"file-fileinfo"},"File, FileInfo"),(0,i.kt)("p",null,"Provide methods for creating, copying, deleting, moving, and opening of files. They have similar interfaces, the only difference is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"FileInfo"),": provides ",(0,i.kt)("strong",{parentName:"li"},"instance")," methods"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"File"),": provides ",(0,i.kt)("strong",{parentName:"li"},"static")," methods.")),(0,i.kt)("p",null,"For small operation it is more suitable to use static methods, but these are security checks done by the operating system, which implies that if you have large set of operations it is better and more efficient to create a FileInfo class instance and access all of its methods."),(0,i.kt)("p",null,"The following are possible methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Create()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Copy()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Delete()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Exists()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetAttributes()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Move()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ReadAllText()"))),(0,i.kt)("h4",{id:"directory-directoryinfo"},"Directory, DirectoryInfo"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Directory"),": provides ",(0,i.kt)("strong",{parentName:"li"},"static")," methods."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DirectoryInfo"),": provides ",(0,i.kt)("strong",{parentName:"li"},"instance")," methods.")),(0,i.kt)("p",null,"The following are possible mehtods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CreateDirectory()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Delete()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Exists()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetCurrentDirectory()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetFiles()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Move()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetLogicalDrives()"))),(0,i.kt)("h4",{id:"path"},"Path"),(0,i.kt)("p",null,"We also have the Path class. Contains methods that work with strings that contains path to file or directory information."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetDirectoryName()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetFileName()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetExtension()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GetTempPath()"))),(0,i.kt)("h3",{id:"path-1"},"Path"),(0,i.kt)("p",null,"This class makes it really easy to work with strings that represent a path. Recommended to look at MSDN documentations so that you don't have to re-invent the wheel. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System;\nusing System.IO;\n\nusing CSharpFundamentals;\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    var path = @"C:\\Projects\\CSharpFundamentals\\HelloWorld\\HelloWorld.sln";\n    \n    // Low-level processing\n    var dotIndex = path.IndexOf(\'.\');\n    var extension = path.Substring(dotIndex);\n\n    // Using Path\n    Console.WriteLine("Extension: " + Path.GetExtension(path)); // .sln\n    Console.WriteLine("File Name: " + Path.GetFileName(path));  // HelloWorld.sln\n    Console.WriteLine("File Name without Extension : " + Path.GetFileNameWithoutExtension(path)); // HelloWorld\n    Console.WriteLine("Directory Name: " + Path.GetDirectoryName(path));  // C:\\Projects\\CSharpFundamentals\\HelloWorld\n  }\n}\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"}," The same can be done with ",(0,i.kt)("inlineCode",{parentName:"p"},"File"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FileInfo"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Directory")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DirectoryInfo")," classes. Consult google search, or the MSDN website to have a look at their methods and how to use them.")),(0,i.kt)("h2",{id:"debugging-applications"},"Debugging Applications"),(0,i.kt)("h3",{id:"debugging-tools-in-visual-studio"},"Debugging Tools in Visual Studio"),(0,i.kt)("h3",{id:"removing-side-effects"},"Removing Side Effects"),(0,i.kt)("h3",{id:"defensive-programming"},"Defensive Programming"),(0,i.kt)("h3",{id:"call-stack-window"},"Call Stack Window"),(0,i.kt)("h3",{id:"locals-and-autos-windows"},"Locals and Autos Windows"))}P.isMDXComponent=!0},4906:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/jit-104a1aba0aeb210380b3498ef831099f.png"},1969:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/os_diff-d5f0bffe119b6f28823feb8ac488a871.png"},3330:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/primitive_types-c44b7780ccf5e2a18ddaaf3a90e36406.png"}}]);