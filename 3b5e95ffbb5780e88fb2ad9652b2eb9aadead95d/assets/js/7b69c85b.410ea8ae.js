"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[1661],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(a),h=i,u=m["".concat(l,".").concat(h)]||m[h]||d[h]||r;return a?n.createElement(u,o(o({ref:t},c),{},{components:a})):n.createElement(u,o({ref:t},c))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},9962:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>v,contentTitle:()=>y,default:()=>T,frontMatter:()=>b,metadata:()=>w,toc:()=>N});var n=a(7462),i=(a(7294),a(3905));const r=a.p+"assets/images/netclasses-0f04c6a3c186bc21c1a445f1a20c301f.png",o=a.p+"assets/images/namespace-8dfd503f04aea03b3f98159cbaf19804.png",s=a.p+"assets/images/assembly-d590e03145e47e959aefde48a791ec35.png",l=a.p+"assets/images/app-de1a721c51bff2e0793b884531c16341.png",p=a.p+"assets/images/arith-97f020fae569b334f1fefdec92f9e352.png",c=a.p+"assets/images/arith1-7b30c90ed3b560f757894daefd0a555b.png",m=a.p+"assets/images/compar-787134f5a4ebbc98a33cbaf29e3d3d52.png",d=a.p+"assets/images/assign_operators-b3d4e502c5bb6641ebb850478f4eae90.png",h=a.p+"assets/images/logical_operators-976c72360ff91d0fa6957f897f437f5e.png",u=a.p+"assets/images/bitwise_operators-6b08a58b27e0a4cc05842a0a24c83233.png",g=a.p+"assets/images/class-9b55ded1f843a2d6b896bb2085544b10.png",k=a.p+"assets/images/static_modifier-3adeafd1c5fabf41bc59006bc112e2a2.png",f=a.p+"assets/images/static_modifier2-1c18424c2fe1893e4d5f338dc2bfe007.png",b={},y="C# Basics Part 1",w={unversionedId:"GAP5005 Games Hardware Development/tutorial-csharp/week1",id:"GAP5005 Games Hardware Development/tutorial-csharp/week1",title:"C# Basics Part 1",description:"Basics Part 1",source:"@site/docs/GAP5005 Games Hardware Development/tutorial-csharp/week1.md",sourceDirName:"GAP5005 Games Hardware Development/tutorial-csharp",slug:"/GAP5005 Games Hardware Development/tutorial-csharp/week1",permalink:"/docs/GAP5005 Games Hardware Development/tutorial-csharp/week1",draft:!1,editUrl:"https://github.com/mohammedfajer/notes/docs/GAP5005 Games Hardware Development/tutorial-csharp/week1.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Tutorial - C# (C-Sharp)",permalink:"/docs/category/tutorial---c-c-sharp"},next:{title:"C# Basics Part 2",permalink:"/docs/GAP5005 Games Hardware Development/tutorial-csharp/week2"}},v={},N=[{value:"C# vs. .NET Framework",id:"c-vs-net-framework",level:2},{value:".NET Framework",id:"net-framework",level:2},{value:"CLR (Common Language Runtime)",id:"clr-common-language-runtime",level:2},{value:"Architecture of .NET Applications",id:"architecture-of-net-applications",level:2},{value:"Primitive Types and Expressions",id:"primitive-types-and-expressions",level:2},{value:"Variables and Constants",id:"variables-and-constants",level:3},{value:"Identifiers",id:"identifiers",level:4},{value:"Naming Conventions",id:"naming-conventions",level:4},{value:"Real Numbers",id:"real-numbers",level:5},{value:"Overflowing",id:"overflowing",level:3},{value:"Scope",id:"scope",level:3},{value:"Type Conversions",id:"type-conversions",level:3},{value:"Operators",id:"operators",level:3},{value:"Arithmetic Operators",id:"arithmetic-operators",level:4},{value:"Comparison Operators",id:"comparison-operators",level:4},{value:"Assignment Operators",id:"assignment-operators",level:4},{value:"Logical Operators",id:"logical-operators",level:4},{value:"Bitwise Operators",id:"bitwise-operators",level:4},{value:"Boolean Algebra",id:"boolean-algebra",level:3},{value:"Logical AND",id:"logical-and",level:4},{value:"Logical OR",id:"logical-or",level:4},{value:"Logical NOT",id:"logical-not",level:4},{value:"Comments",id:"comments",level:3},{value:"Single-line Comment",id:"single-line-comment",level:4},{value:"Multi-line Comments",id:"multi-line-comments",level:4},{value:"When to use",id:"when-to-use",level:4},{value:"Non-Primitive Types",id:"non-primitive-types",level:2},{value:"Classes",id:"classes",level:3},{value:"Creating Objects",id:"creating-objects",level:4},{value:"Static Modifier",id:"static-modifier",level:4},{value:"Structs",id:"structs",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Declaring Arrays",id:"declaring-arrays",level:4},{value:"Accessing Array Elements",id:"accessing-array-elements",level:4},{value:"Strings",id:"strings",level:3},{value:"Enums",id:"enums",level:3},{value:"Reference Types and Value Types",id:"reference-types-and-value-types",level:3},{value:"Control Flow",id:"control-flow",level:2},{value:"Conditional Statements",id:"conditional-statements",level:3},{value:"Iteration Statements",id:"iteration-statements",level:3},{value:"Random Class",id:"random-class",level:3},{value:"Arrays and Lists",id:"arrays-and-lists",level:2},{value:"Arrays",id:"arrays-1",level:3},{value:"Lists",id:"lists",level:3},{value:"Working with Dates",id:"working-with-dates",level:2},{value:"DateTime",id:"datetime",level:3},{value:"TimeSpan",id:"timespan",level:3},{value:"Working with Text",id:"working-with-text",level:2},{value:"String",id:"string",level:3},{value:"StringBuilder",id:"stringbuilder",level:3},{value:"Procedural Programming",id:"procedural-programming",level:3},{value:"Working with Files",id:"working-with-files",level:2},{value:"Introduction to System.IO",id:"introduction-to-systemio",level:3},{value:"File and File Info",id:"file-and-file-info",level:3},{value:"Directory and Directory Info",id:"directory-and-directory-info",level:3},{value:"Path",id:"path",level:3},{value:"Debugging Applications",id:"debugging-applications",level:2},{value:"Debugging Tools in Visual Studio",id:"debugging-tools-in-visual-studio",level:3},{value:"Removing Side Effects",id:"removing-side-effects",level:3},{value:"Defensive Programming",id:"defensive-programming",level:3},{value:"Call Stack Window",id:"call-stack-window",level:3},{value:"Locals and Autos wINDOWS",id:"locals-and-autos-windows",level:3}],C={toc:N},x="wrapper";function T(e){let{components:t,...b}=e;return(0,i.kt)(x,(0,n.Z)({},C,b,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"c-basics-part-1"},"C# Basics Part 1"),(0,i.kt)("p",null,"In this tutorial we will learn the basics of C#. This is very high quality tutorial, a comprehensive and deep understanding of C# will be obtained by the end of this 3 part tutorial pages."),(0,i.kt)("h2",{id:"c-vs-net-framework"},"C# vs. .NET Framework"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C# is a programming language (statically typed and object-oriented)"),(0,i.kt)("li",{parentName:"ul"},".NET is a framework for building applications on Windows")),(0,i.kt)("h2",{id:"net-framework"},".NET Framework"),(0,i.kt)("p",null,".NET Framework consist of the following two components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"CLR (Common Language Runtime)"),(0,i.kt)("li",{parentName:"ul"},"Class Library")),(0,i.kt)("h2",{id:"clr-common-language-runtime"},"CLR (Common Language Runtime)"),(0,i.kt)("p",null,"For languages like ",(0,i.kt)("inlineCode",{parentName:"p"},"c/c++")," when we compile the application, the ",(0,i.kt)("strong",{parentName:"p"},"compiler")," translates our code and we get a native machine code. Which means if we write an application in ",(0,i.kt)("inlineCode",{parentName:"p"},"c++")," on Windows machine   with 86x processor architecture, the compiler would translate our code into the native code for that machine. But, we have different hardwares, different operating systems, so if we take that application (compiled program) into a computer with a different operating system and CPU architecture, that would not run. "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"OS Difference",src:a(1969).Z,width:"2135",height:"1075"})),(0,i.kt)("p",null,"So when ",(0,i.kt)("strong",{parentName:"p"},"Microsoft")," was designing the C# language, and the .NET framework, came with an idea that borrowed from Java language, in Java when you compile a program it translates to intermediate language called ",(0,i.kt)("strong",{parentName:"p"},"ByteCode")," and we have the same exact concept in C#."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Just-In-Time-Compilation",src:a(4906).Z,width:"1790",height:"1209"})),(0,i.kt)("p",null,"When we compile a C# application we get a ",(0,i.kt)("strong",{parentName:"p"},"IL")," Code (Intermediate Language) is independent from the computer its running on, then we have something that translate that IL intermediate code into the native machine code. That is the job of then ",(0,i.kt)("strong",{parentName:"p"},"CLR"),", it is an application that sitting in the memory whose job is to translate the IL code into the machine code. This process is called ",(0,i.kt)("strong",{parentName:"p"},"Just-in-time Compilation (JIT)"),". With this architecture, you can write an application in C# and don't have to worry about compiling that into the native code for different machines, as long as the machine has ",(0,i.kt)("strong",{parentName:"p"},"CLR")," that can run your application."),(0,i.kt)("h2",{id:"architecture-of-net-applications"},"Architecture of .NET Applications"),(0,i.kt)("p",null,"Let us learn now about the architecture of .NET applications, at a very high level, when you build an application with C#, your application consist of building blocks called ",(0,i.kt)("strong",{parentName:"p"},"classes"),". These classes collaborate with each other at runtime, and as a result the application provides some functionality. "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:r,width:"50%",alt:".NET Classes"})),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"class")," contains some data (attributes/fields) and some functions (methods/behaviours), data represent the ",(0,i.kt)("u",null,"state")," of the application."),(0,i.kt)("p",null,"Now as the number of classes grows, we need a way to organize these classes, that is where we use a ",(0,i.kt)("strong",{parentName:"p"},"Namespace"),".  A Namespace, is a container for related classes. For example, in the .NET framework, we have namespaces containing tens of related classes, we have namespaces for working with data like databases, we have namespaces for working with graphics and images, we have namespaces for working with security. "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:o,width:"50%",alt:"Namespaces"})),(0,i.kt)("p",null,"Now, in real world applications, as these namespaces grow, we need a different way of partitioning an application and that when we use an ",(0,i.kt)("strong",{parentName:"p"},"Assembly"),". An Assembly, is a container for related namespaces, physically it is a ",(0,i.kt)("strong",{parentName:"p"},"file")," on the disk, which can either be a an ",(0,i.kt)("strong",{parentName:"p"},"executable (EXE)")," or a ",(0,i.kt)("strong",{parentName:"p"},"DLL (Dynamically Linked Library)"),". "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:s,width:"50%",alt:"Assembly"})),(0,i.kt)("p",null,"When you compile your application, the compiler, builds one or more assemblies depending on how you partitioned your code."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:l,width:"50%",alt:"App"})),(0,i.kt)("h2",{id:"primitive-types-and-expressions"},"Primitive Types and Expressions"),(0,i.kt)("p",null,"This section will explore the concepts of  ",(0,i.kt)("strong",{parentName:"p"},"Variables and Constants"),", ",(0,i.kt)("strong",{parentName:"p"},"Data Types"),", ",(0,i.kt)("strong",{parentName:"p"},"Type Conversion and Overflowing"),", ",(0,i.kt)("strong",{parentName:"p"},"Scope"),", ",(0,i.kt)("strong",{parentName:"p"},"Operators")," and ",(0,i.kt)("strong",{parentName:"p"},"Comments"),"."),(0,i.kt)("h3",{id:"variables-and-constants"},"Variables and Constants"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Variable")," is a name given to a storage location in memory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Constant")," is an immutable value")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// General Syntax : <const> <data-type> <identifier> = <value>;\n\n// Declaring Variables and Constants\nint number;\n\n// Initialize Variables\nint Number = 1;\n\nconst float Pi = 3.14f;\n")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Note: that ",(0,i.kt)("strong",{parentName:"p"},"C#")," is a case-sensitive language, meaning these two identifiers ",(0,i.kt)("strong",{parentName:"p"},"number")," and ",(0,i.kt)("strong",{parentName:"p"},"Number")," are different. Also variables ",(0,i.kt)("strong",{parentName:"p"},"must")," be ",(0,i.kt)("u",null,"initialized")," before usage, otherwise you get a compile-time error.")),(0,i.kt)("h4",{id:"identifiers"},"Identifiers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Cannot start with a number"),(0,i.kt)("li",{parentName:"ul"},"Cannot include a whitespace"),(0,i.kt)("li",{parentName:"ul"},"Cannot be a reserved keyword"),(0,i.kt)("li",{parentName:"ul"},"Use meaningful names.")),(0,i.kt)("h4",{id:"naming-conventions"},"Naming Conventions"),(0,i.kt)("p",null,"Some popular variable naming conventions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Camel Case          : ",(0,i.kt)("inlineCode",{parentName:"li"},"firstName")),(0,i.kt)("li",{parentName:"ul"},"Pascal Case         : ",(0,i.kt)("inlineCode",{parentName:"li"},"FirstName")),(0,i.kt)("li",{parentName:"ul"},"Hungarian Notation  : ",(0,i.kt)("inlineCode",{parentName:"li"},"strFirstName")),(0,i.kt)("li",{parentName:"ul"},"Snake Case          : ",(0,i.kt)("inlineCode",{parentName:"li"},"variable_one"))),(0,i.kt)("p",null,"Its usually preferred to use camel case, and avoid hungarian notation."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"CSharp Primitive Types",src:a(3330).Z,width:"1577",height:"641"})),(0,i.kt)("h5",{id:"real-numbers"},"Real Numbers"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"double")," is the default type for floating-point decimal numbers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"float   number = 1.2f; // To tell the compiler to treat the number as a float otherwise it would be double\ndecimal number = 1.2m; \n")),(0,i.kt)("p",null,"To learn more you can google search:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C# built-in types"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://msdn.microsoft.com/en-us/library/cs7y5x0x(v=vs.90).aspx"},"http://msdn.microsoft.com/en-us/library/cs7y5x0x(v=vs.90).aspx"))),(0,i.kt)("h3",{id:"overflowing"},"Overflowing"),(0,i.kt)("p",null,"Now we talk about the concept of ",(0,i.kt)("strong",{parentName:"p"},"overflowing"),". Consider the following code snippet."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"byte number = 255;\n\nnumber = number + 1; // 0\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"255")," is the largest value we can store in a byte. In the second line we are trying to increment number one to have 256. But if you compile and run your application you will see ",(0,i.kt)("inlineCode",{parentName:"p"},"zero (0)"),". This is what we call overflowing. We have exceeded the boundary of the byte data type. In C# by default we don't have overflowing checking, which means we can modify the value of a variable at runtime and if we go beyond the boundary of its underlying data type, we will get overflow. Sometimes this is not desirable in our application and want to stop overflowing, if that is the case we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"checked")," keyword."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"checked \n{\n  byte number = 255;\n\n  number = number + 1; \n}\n")),(0,i.kt)("p",null,"With this code, overflow will not happen at ",(0,i.kt)("strong",{parentName:"p"},"runtime"),", instead an exception will be thrown and the program will crash unless you handle the exception. We will cover exception now, but much later in part 3 of the C# tutorial. In reality this is rarely happens, since if we are concerned about overflow, we simply use a bigger data type such as ",(0,i.kt)("inlineCode",{parentName:"p"},"short")," in this example. There is also the case when the result is smaller than the smallest value that can be stored or represented, these are often called ",(0,i.kt)("strong",{parentName:"p"},"underflows"),"."),(0,i.kt)("h3",{id:"scope"},"Scope"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Where a variable / constant has meaning. Take a look at the following code snippet.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"{\n  byte a = 1;\n  {\n    byte b = 2;\n    {\n      byte c = 3;\n    }\n  }\n}\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"block")," is indicated by a pair of curly braces ",(0,i.kt)("inlineCode",{parentName:"p"},"{}"),".  Here we have three blocks of code, the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is accessible in that block or any child blocks, if you try to access the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," outside of the first block, the program will not compile. The same rule applies to the other variables ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is meaningful in its scope block and any of its children blocks. "),(0,i.kt)("h3",{id:"type-conversions"},"Type Conversions"),(0,i.kt)("p",null,"We will be taking about various kinds of type conversion."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implicit type conversion"),(0,i.kt)("li",{parentName:"ul"},"Explicit type conversion (Casting)"),(0,i.kt)("li",{parentName:"ul"},"Conversion between non-compatible types")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("h4",{parentName:"admonition",id:"implicit-type-conversion"},"Implicit Type Conversion"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"byte b = 1;       //                            000000001\nint i = b;        // 00000000 00000000 00000000 00000001\n")),(0,i.kt)("p",{parentName:"admonition"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"byte")," takes only one byte of memory and an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," takes four bytes of memory. So we can easily copy a byte into an integer. As can be shown from the ",(0,i.kt)("u",null,"binary representation"),", there is no data lose, when the compiler is sure that the data types are compatible and no data loss will happen, values can be converted to a different type ",(0,i.kt)("inlineCode",{parentName:"p"},"implicitly"),"."),(0,i.kt)("p",{parentName:"admonition"},"An example of something that won't compile:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int i = 1;\nbyte b = i; //  won't compile\n")),(0,i.kt)("p",{parentName:"admonition"},"In this example, we declared an integer and we are trying to copy that to a byte, an integer is four bytes, so when we convert that to a byte, three bytes out of four bytes will be gone, and there is a chance for data loss, now ",(0,i.kt)("inlineCode",{parentName:"p"},"data loss")," doesn't always happen, it only happens if the value we stored in the integer is beyond the capacity of a byte, in this example ",(0,i.kt)("inlineCode",{parentName:"p"},"one")," can be stored in a byte, so no data loss will happen, but if we had ",(0,i.kt)("inlineCode",{parentName:"p"},"300")," here, we cannot store ",(0,i.kt)("inlineCode",{parentName:"p"},"300")," in a byte and as a result of that conversion data will be lost. When the compiler knows there is a chance for data loss, it doesn't allow ",(0,i.kt)("inlineCode",{parentName:"p"},"implicit type conversion")," and you need to explicitly tell the compiler that you are aware of the data loss and you still want to go ahead with the conversion.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("h4",{parentName:"admonition",id:"explicit-type-conversion"},"Explicit Type Conversion"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int i = 1;\nbyte b = (byte) i;\n")),(0,i.kt)("p",{parentName:"admonition"},"This is the same as the last example, the only difference is we have prefixed ",(0,i.kt)("inlineCode",{parentName:"p"},"(byte)")," before assigning the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". Which means we are trying to convert ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," into a byte. This is called as ",(0,i.kt)("inlineCode",{parentName:"p"},"casting"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"float f = 1.0f;\nint i = (int)f;\n")),(0,i.kt)("p",{parentName:"admonition"},"Here is another example, casting tells the compiler I am aware of the data loss and still wants to convert ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," which is a float into an integer.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("h4",{parentName:"admonition",id:"non-compatible-types"},"Non-compatible types"),(0,i.kt)("p",{parentName:"admonition"},"Sometimes we have non-compatible types but still need to convert between them."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'string s = "1";\nint i = (int)s; // won\'t compile\n')),(0,i.kt)("p",{parentName:"admonition"},"In this example and similar examples, is where we have a number represented as a string, and we need to convert it to an integer. Since in this situation string and integer are not compatible, we cannot use explicit casting.  "),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'string s  = "1";\nint i     = Convert.ToInt32(s); // Method 1\nint j     = int.Parse(s);       // Method 2\n')),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"Convert")," class is part of the .NET framework, and is defined in Systems namespace. Contains different methods for conversion and they all start with ",(0,i.kt)("inlineCode",{parentName:"p"},"To..."),". The second method is ",(0,i.kt)("inlineCode",{parentName:"p"},"Parse"),", all primitive types have this ",(0,i.kt)("inlineCode",{parentName:"p"},"Parse")," method, and the parse method takes in a string and tried to convert that to the target type. "),(0,i.kt)("p",{parentName:"admonition"},"The following are some of the methods you can use and find in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Convert")," class:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Convert.ToByte  (s);\nConvert.ToInt16 (s);\nConvert.ToInt32 (s);\nConvert.ToInt64 (s);\n"))),(0,i.kt)("p",null,"Sample C# Program using type conversion."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'\nusing System; // Namespace System\n\nnamespace TypeConversion\n{\n  class Program\n  {\n    static void Main(string[] args)\n    {\n      try\n      {\n        string str = "true";\n        bool a = Convert.ToBoolean(str);\n        Console.WriteLine(a);\n\n        // The try-catch for this case.\n        var number = "1234";\n        byte b = Convert.ToByte(number);\n        Console.WriteLine(b);\n      }\n      catch(Exception)\n      {\n        Console.WriteLine("The number could not be converted to a byte.");\n      }\n    }\n  }\n}\n\n\n')),(0,i.kt)("h3",{id:"operators"},"Operators"),(0,i.kt)("p",null,"In C# we have the following five types of operators:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Arithmetic Operators"),(0,i.kt)("li",{parentName:"ul"},"Comparison Operators"),(0,i.kt)("li",{parentName:"ul"},"Assignment Operators"),(0,i.kt)("li",{parentName:"ul"},"Logical Operators"),(0,i.kt)("li",{parentName:"ul"},"Bitwise Operators")),(0,i.kt)("h4",{id:"arithmetic-operators"},"Arithmetic Operators"),(0,i.kt)("p",null,"In computation, when we are working with numbers."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:p,width:"50%",alt:"Arithmetic Operators"})),(0,i.kt)("p",null,"We also have two arithmetic operators called ",(0,i.kt)("inlineCode",{parentName:"p"},"increment")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"decrement"),"."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:c,width:"50%",alt:"Arithmetic Operators 2"})),(0,i.kt)("p",null,"Which are shortcuts for adding or subtracting one. Note, with this increment and decrement operators, there are two ways in which you can apply them. ",(0,i.kt)("inlineCode",{parentName:"p"},"Postfix Increment")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Prefix Increment"),". "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Postfix Increment\nint a = 1;\nint b = a++; // b = 1, a = 2;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Prefix Increment\nint a = 1;\nint b = ++a; // b = 2, a = 2;\n")),(0,i.kt)("h4",{id:"comparison-operators"},"Comparison Operators"),(0,i.kt)("p",null,"Comparing values, can be accomplished using comparison operators."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:m,width:"50%",alt:"Comparison Operators"})),(0,i.kt)("p",null,"Note the difference between the assignment operator ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," and the equality check ",(0,i.kt)("inlineCode",{parentName:"p"},"=="),"."),(0,i.kt)("h4",{id:"assignment-operators"},"Assignment Operators"),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:d,width:"50%",alt:"Assignment Operators"})),(0,i.kt)("h4",{id:"logical-operators"},"Logical Operators"),(0,i.kt)("p",null,"Logical operators are used in ",(0,i.kt)("strong",{parentName:"p"},"boolean expressions")," which are often used in conditional statements."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:h,width:"50%",alt:"Logical Operators"})),(0,i.kt)("h4",{id:"bitwise-operators"},"Bitwise Operators"),(0,i.kt)("p",null,"These are often used in low-level programming. For example, when working with ",(0,i.kt)("inlineCode",{parentName:"p"},"Win32")," api or sockets or encryption. "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:u,width:"50%",alt:"Bitwise Operators"})),(0,i.kt)("h3",{id:"boolean-algebra"},"Boolean Algebra"),(0,i.kt)("p",null,"Logical operators are part of Boolean algebra, the value of variables can only be ",(0,i.kt)("strong",{parentName:"p"},"true")," or ",(0,i.kt)("strong",{parentName:"p"},"false"),", also denoted 1 or 0 respectively. Unlike elementary algebra, where the main operations are addition, subtraction, etc, the main operations of Boolean Algebra are ",(0,i.kt)("strong",{parentName:"p"},"conjunction")," (AND), ",(0,i.kt)("strong",{parentName:"p"},"disjunction")," (OR) and ",(0,i.kt)("strong",{parentName:"p"},"negation")," (NOT)."),(0,i.kt)("h4",{id:"logical-and"},"Logical AND"),(0,i.kt)("p",null,"Let\u2019s assume we have two variables: ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y"),". In C#, the logical AND operator is indicated by &&. We can define a Boolean expression as follows:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"z = x && y")),(0,i.kt)("p",null,"In this expression, ",(0,i.kt)("strong",{parentName:"p"},"z")," is true if both ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y")," are true; otherwise, it\u2019ll be false."),(0,i.kt)("p",null,"What is a real-world example of this in programming? Imagine you\u2019re developing a loan application. The provider only offers loans to applicants who are over 18 and are citizen of the given country. In this example, we have two variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"x = applicant being over 18\ny = application being a citizen\nz = is eligible to apply for loan = x && y\n")),(0,i.kt)("p",null,"If both ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y")," are true, the applicant is eligible to apply for a loan. Later, when we get to conditional statements, you can check to see if the above expression evaluates to true or false, and then, can change the flow of your application. "),(0,i.kt)("p",null,"So, here is the rule of thumb with logical AND: if both ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y")," are true, ",(0,i.kt)("strong",{parentName:"p"},"x && y")," will be true; otherwise, it\u2019ll be false"),(0,i.kt)("h4",{id:"logical-or"},"Logical OR"),(0,i.kt)("p",null,"In C#, logical OR is indicated by two vertical lines (||). Considering the following expression:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"z = x || y")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"z")," will be true, if either ",(0,i.kt)("strong",{parentName:"p"},"x")," or ",(0,i.kt)("strong",{parentName:"p"},"y")," is true."),(0,i.kt)("p",null,"What is a real-world example of this? Imagine you're building software for a recruiter. For a given job application, applicants can apply if they have a degree in computing, or more than 5 years of experience in the field. You can model this using a Boolean expression as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"x = applicant has a degree in computing\ny = applicant has more than 5 years of experience\n\nz = application is eligible = x || y\n")),(0,i.kt)("p",null,"If either x or y is true, z will be true."),(0,i.kt)("p",null,"So, unlike the logical AND, where both variables must be true, with logical OR, if at least one of them is true, the result will be true."),(0,i.kt)("h4",{id:"logical-not"},"Logical NOT"),(0,i.kt)("p",null,"The NOT operator in C# is indicated by an exclamation mark (!) and it reverse or flip the value of a given variable or expression."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"y = !x")),(0,i.kt)("p",null,"so, here, if ",(0,i.kt)("strong",{parentName:"p"},"x")," is true, ",(0,i.kt)("strong",{parentName:"p"},"y")," will be false,  and if ",(0,i.kt)("strong",{parentName:"p"},"x")," is false, ",(0,i.kt)("strong",{parentName:"p"},"y")," will be true."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("h2",{parentName:"admonition",id:"clean-coding"},"Clean Coding"),(0,i.kt)("p",{parentName:"admonition"},"In all examples, here, I used variables ",(0,i.kt)("strong",{parentName:"p"},"x")," and ",(0,i.kt)("strong",{parentName:"p"},"y"),", mainly to relate programming to Boolean algebra. But when it comes to coding, you should avoid using variable names such as x, y, z as they don't give a clue to other developers reading your code (or even yourself). Instead, use meaningful names. For instance, in the first example, you can replace ",(0,i.kt)("strong",{parentName:"p"},"x"),", ",(0,i.kt)("strong",{parentName:"p"},"y"),", and ",(0,i.kt)("strong",{parentName:"p"},"z")," as follows:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"x : isOver18\ny : isCitizen\nz : isEligible\n")),(0,i.kt)("p",{parentName:"admonition"},"often, it's a good practice to prefix Boolean names with IS or HAS (if possible).")),(0,i.kt)("h3",{id:"comments"},"Comments"),(0,i.kt)("p",null,"A text we put into our code to improve its readability and maintainability. In C# we have two ways to write comments. "),(0,i.kt)("h4",{id:"single-line-comment"},"Single-line Comment"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Here is a single-line comment\nint a = 1;\n")),(0,i.kt)("h4",{id:"multi-line-comments"},"Multi-line Comments"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"/*\n  Here is a multi-line\n  comment\n*/\nint a = 1;\n")),(0,i.kt)("h4",{id:"when-to-use"},"When to use"),(0,i.kt)("p",null,"To explain whys, hows, constrains, etc. not the whats. Keep your comments to a minimum, use only when required. Do not explain what the code is doing, your code should be so clean and straight forward, that it does not need comments.  If the comment is just explaining what the code is doing, then its redundant and the problem with redundant comments is we change the code but not everyone is very consistent in changing the comments, so after a while the comments become out-dated and there is no way to validate them and after a while they become useless."),(0,i.kt)("h2",{id:"non-primitive-types"},"Non-Primitive Types"),(0,i.kt)("p",null,"In this section we will be taking about the non-primitive data structures of C#. Such as ",(0,i.kt)("strong",{parentName:"p"},"Classes"),", ",(0,i.kt)("strong",{parentName:"p"},"Structures"),",  ",(0,i.kt)("strong",{parentName:"p"},"Arrays"),", ",(0,i.kt)("strong",{parentName:"p"},"Strings")," and ",(0,i.kt)("strong",{parentName:"p"},"Enums"),".  Then will discuss important topics of ",(0,i.kt)("inlineCode",{parentName:"p"},"reference types vs value types")," which are about memory management of different types in C# language."),(0,i.kt)("h3",{id:"classes"},"Classes"),(0,i.kt)("p",null,"Classes are the building blocks of our applications. Class combines related variables (fields) amd functions (methods). "),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:g,width:"50%",alt:"Classes"})),(0,i.kt)("p",null,"A class is a ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"blueprint")," from which we create ",(0,i.kt)("strong",{parentName:"p"},"objects"),". An object is an ",(0,i.kt)("strong",{parentName:"p"},"instance")," of a class. When you run your applications, its the objects that talk to each other and collaborating to provide some functionality."),(0,i.kt)("p",null,"To create a class in C# we start with an ",(0,i.kt)("strong",{parentName:"p"},"access modifier")," then the class keyword and an Identifier."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public class Person\n{\n  public string Name;\n\n  public void Introduce()\n  {\n    Console.WriteLine("Hi, my name is " + Name);\n  }\n}\n')),(0,i.kt)("p",null,"Public makes the class accessible from anywhere in your application. We declare the variables inside the class scope block, they are called fields and also require access modifier. We can also define methods, in this case we have a method that does not return anything and that takes no arguments. It just outputs the name of the person on the console."),(0,i.kt)("p",null,"Here is another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Calculator\n{\n  public int Add(int a, int b)\n  {\n    return a + b;\n  }\n}\n")),(0,i.kt)("p",null,"A calculator class with one method that takes two integers and return an integer."),(0,i.kt)("h4",{id:"creating-objects"},"Creating Objects"),(0,i.kt)("p",null,"Creating objects, or instances of classes, we need to allocate memory for the new object. They are treated different than primitive types. But unlike other languages like ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"c++"),", you don't have to worry about ",(0,i.kt)("inlineCode",{parentName:"p"},"deallocating")," that memory. CLR (Common Language Runtime) will take care of that for you, it has a process called ",(0,i.kt)("strong",{parentName:"p"},"garbage collection")," which automatically removes all objects that are not used. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Person person = new Person();\n")),(0,i.kt)("p",null,"To allocate memory to a new object on the heap, we use the ",(0,i.kt)("strong",{parentName:"p"},"new")," operator and repeat the type of the class and parenthesis.  We can use this code shorter by using the ",(0,i.kt)("strong",{parentName:"p"},"var")," keyword, which let the compiler determine the type of the variable at compile-time, you can thing of ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," in C++."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'var person = new Person();\n\n// Access object members\nperson.Name = "Mohammed";\nperson.Introduce();\n')),(0,i.kt)("h4",{id:"static-modifier"},"Static Modifier"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Calculator\n{\n  public static int Add(int a, int b)\n  {\n    return a + b;\n  }\n}\n")),(0,i.kt)("p",null,"We have added the ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," keyword to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Add(...)")," method and as a result we can access this method directly from the class without creating an instance or object. the Add() method is a static member, and we can't access static members from objects."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int result = Calculator.Add(1,2);\n")),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:k,width:"50%",alt:"Static Modifier"})),(0,i.kt)("p",null,"Without static modifier, when we create let say three objects of the type Calculator class, each object in the member will have the add method.  But when you apply the static modifier, that method will be in only one place in memory. And that is the calculator class itself. So it will not be repeated three times in memory."),(0,i.kt)("div",{class:"image-container"},(0,i.kt)("img",{src:f,width:"50%",alt:"Static Modifier 2"})),(0,i.kt)("p",null,"Why do we need this, we use the static modifier when we represent a concept that a single instance of that should exist in memory.  For example, the program ",(0,i.kt)("strong",{parentName:"p"},"entry point")," main function, is static. Which means there is only one instance of the main method in memory, there is only one entry point in C#. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class Program\n{\n  static void Main()\n  {\n  }\n}\n")),(0,i.kt)("h3",{id:"structs"},"Structs"),(0,i.kt)("p",null,"C# has something similar to classes called ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," for structure. Which is a bundle of data, you can think of it a memory region. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public struct RgbColor\n{\n  public int Red;\n  public int Green;\n  public int Blue;\n}\n")),(0,i.kt)("p",null,"Combine related fields and methods together, although its similar to classes but has distinct differences. Use a structure when you want to define a small lightweight object. E.g. rgb color, a point. Its more efficient for having multiple small objects, like 1000 points or colors."),(0,i.kt)("h3",{id:"arrays"},"Arrays"),(0,i.kt)("p",null,"Another non-primitive type we have in C# is array. The following section will introduce the basics of arrays in C#, later we will go more in depth. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Array")," A data structure to store a collection of variables of the same type."),(0,i.kt)("h4",{id:"declaring-arrays"},"Declaring Arrays"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int number1;\nint number2;\nint number3;\n\nint[] numbers = new int[3];\n")),(0,i.kt)("p",null,"Imagine you want to work with three numbers, instead of having three different variables, you can define a variable array that can work with three numbers. You need to allocate memory and is an object behind the scene, the compiler creates an instance of the Array class."),(0,i.kt)("h4",{id:"accessing-array-elements"},"Accessing Array Elements"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"int[] numbers = new int[3];\n\nnumbers[0] = 1;\nnumbers[1] = 2;\nnumbers[2] = 3;\n\n")),(0,i.kt)("p",null,"Note in C# arrays are ",(0,i.kt)("inlineCode",{parentName:"p"},"zero-indexed")," which means the first element in the array start at index 0. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// If you know the values before hand you can use the object initializer list and make the code shorter\nint[] numbers = new int[3] {1,2,3};\n")),(0,i.kt)("h3",{id:"strings"},"Strings"),(0,i.kt)("h3",{id:"enums"},"Enums"),(0,i.kt)("p",null,"Another type is Enum, it is a data type that represent a set of name/value pairs (constants). "),(0,i.kt)("p",null,"Example: Imagine you are building an application for post company and want to support few different shipping methods."),(0,i.kt)("p",null,"One way you can declare a few constants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"const int RegularAirMail = 1;\nconst int RegisteredAirMail = 2;\nconst int Express = 3;\n")),(0,i.kt)("p",null,"each representing a shipping method, and in your application based on the shipping method, you can make decisions to calculate the shipping cost, or the tax or display different messages to the user, so possibilities are endless. Even though this approach works, its a little bit messy. It is better to define a new type, where we can represent different shipping methods so that where we use an ",(0,i.kt)("strong",{parentName:"p"},"Enum"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public enum ShippingMethod\n{\n  RegularAirMail = 1,\n  RegisteredAirMail = 2,\n  Express = 3\n}\n")),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"enums")," where you have a number of related constants. Instead of declaring multiple constants, declare an enum, this will be a new type in our applications, just like classes or structures. We can use enum with the ",(0,i.kt)("inlineCode",{parentName:"p"},".")," dot notation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var method = ShippingMethod.Express;\n")),(0,i.kt)("p",null,"Note: enum internally is an integer but if you have a reason to change that, then you can specify that type during declaration  of your enum."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public enum ShippingMethod : byte\n{\n  RegularAirMail = 1,\n  RegisteredAirMail = 2,\n  Express = 3\n}\n")),(0,i.kt)("p",null,"Example Program Using Enum."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using System;\n\nnamespace CSharpFundamentals\n{\n  // by default set to zero, and the next are incremented by one\n  public enum ShippingMethod\n  {\n    RegularAirMail = 1, \n    RegisteredAirMail = 2,\n    Express = 3\n  }\n\n  class Program\n  {\n    static void Main(string[] args)\n    {\n      // Using Integers\n      var method = ShippingMethod.Express;\n      Console.WriteLine((int)method); // Casting \n\n      var methodId = 3;\n      Console.WriteLine((ShippingMethod)methodId); // Express\n\n      // Using strings\n      Console.WriteLine(method.ToString()); // Express\n      Console.WriteLine(method); // Console.WriteLine calls method ToString method.\n\n      var methodName = "Express";\n      ShippingMethod shippingMethod = (ShippingMethod) Enum.Parse(typeof(ShippingMethod), methodName);\n    }\n  }\n}\n\n')),(0,i.kt)("h3",{id:"reference-types-and-value-types"},"Reference Types and Value Types"),(0,i.kt)("h2",{id:"control-flow"},"Control Flow"),(0,i.kt)("h3",{id:"conditional-statements"},"Conditional Statements"),(0,i.kt)("h3",{id:"iteration-statements"},"Iteration Statements"),(0,i.kt)("h3",{id:"random-class"},"Random Class"),(0,i.kt)("h2",{id:"arrays-and-lists"},"Arrays and Lists"),(0,i.kt)("h3",{id:"arrays-1"},"Arrays"),(0,i.kt)("h3",{id:"lists"},"Lists"),(0,i.kt)("h2",{id:"working-with-dates"},"Working with Dates"),(0,i.kt)("h3",{id:"datetime"},"DateTime"),(0,i.kt)("h3",{id:"timespan"},"TimeSpan"),(0,i.kt)("h2",{id:"working-with-text"},"Working with Text"),(0,i.kt)("h3",{id:"string"},"String"),(0,i.kt)("h3",{id:"stringbuilder"},"StringBuilder"),(0,i.kt)("h3",{id:"procedural-programming"},"Procedural Programming"),(0,i.kt)("h2",{id:"working-with-files"},"Working with Files"),(0,i.kt)("h3",{id:"introduction-to-systemio"},"Introduction to System.IO"),(0,i.kt)("h3",{id:"file-and-file-info"},"File and File Info"),(0,i.kt)("h3",{id:"directory-and-directory-info"},"Directory and Directory Info"),(0,i.kt)("h3",{id:"path"},"Path"),(0,i.kt)("h2",{id:"debugging-applications"},"Debugging Applications"),(0,i.kt)("h3",{id:"debugging-tools-in-visual-studio"},"Debugging Tools in Visual Studio"),(0,i.kt)("h3",{id:"removing-side-effects"},"Removing Side Effects"),(0,i.kt)("h3",{id:"defensive-programming"},"Defensive Programming"),(0,i.kt)("h3",{id:"call-stack-window"},"Call Stack Window"),(0,i.kt)("h3",{id:"locals-and-autos-windows"},"Locals and Autos wINDOWS"))}T.isMDXComponent=!0},4906:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/jit-104a1aba0aeb210380b3498ef831099f.png"},1969:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/os_diff-d5f0bffe119b6f28823feb8ac488a871.png"},3330:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/primitive_types-c44b7780ccf5e2a18ddaaf3a90e36406.png"}}]);